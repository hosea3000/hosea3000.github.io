<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Nodejs on Hosea 的个人笔记</title><link>https://hosea3000.github.io/nodejs/</link><description>Recent content in Nodejs on Hosea 的个人笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 21 Oct 2022 02:02:33 +0800</lastBuildDate><atom:link href="https://hosea3000.github.io/nodejs/index.xml" rel="self" type="application/rss+xml"/><item><title>Array</title><link>https://hosea3000.github.io/nodejs/array/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/array/</guid><description>Js 判斷對象是否為數組 ECMAScript5 中有一個現成的方法：Array.isArray() 1 2 3 4 5 6 var obj = { 1: [1], 2: [2] }, arr = [1], str = &amp;#39;1&amp;#39;; Array.isArray(obj); // return false Array.isArray(arr); // return true Array.isArray(str); // return false instanceof</description></item><item><title>decorator 装饰器</title><link>https://hosea3000.github.io/nodejs/decorator/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/decorator/</guid><description>js 目前也有类似于 Java 和 Python 的装饰器概念, 主要写法如下 1 2 3 4 5 6 7 8 9 @frozen class Foo { @configurable(false) @enumerable(true) method() {} @throttle(500) expensiveMethod() {} } 目前在 Node.js 中还无法使用这个特性, 那么他是怎么实现的呢</description></item><item><title>Express 错误处理中间件如何捕获 async 方法的异常?</title><link>https://hosea3000.github.io/nodejs/express/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/express/</guid><description>问题示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const express = require(&amp;#39;express&amp;#39;); const app = express(); app.get(&amp;#39;/&amp;#39;, async (req, res, next) =&amp;gt; { throw new Error(&amp;#39;test error&amp;#39;); }); app.use(async function (error, req, res, next) { console.log(&amp;#39;will not print&amp;#39;); // 这里无法捕获到错误, 关键点在于actio</description></item><item><title>js 中 sort 数字排序问题</title><link>https://hosea3000.github.io/nodejs/sort/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/sort/</guid><description>js 中 sort 数字排序问题 语法：arrayObject.sort(sortby)；参数 sortby 可选。规定排序顺序。必须是函数。 sort() 方法用于对数组的元素进行排</description></item><item><title>JS 中的||符号</title><link>https://hosea3000.github.io/nodejs/operator/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/operator/</guid><description>1、JS 中的||符号： 运算方法： ​ 只要“||”前面为 false,不管“||”后面是 true 还是 false，都返回“||”后面的值。 ​ 只要“||”前</description></item><item><title>Nest.js</title><link>https://hosea3000.github.io/nodejs/nestjs/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/nestjs/</guid><description>前言 分层是解决软件复杂度很好的方法，它能够降低耦合、增加复用。典型的 java 后端开发大多分为三层，几乎成了标准模式，但是 node 社区对于分层的讨论却很少</description></item><item><title>Node.js 中的异常捕获</title><link>https://hosea3000.github.io/nodejs/exception/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/exception/</guid><description>Node.js 中的异常捕获 同步代码的错误处理 同步代码中的异常使用 try{}catch 结构即可捕获处理。 1 2 3 4 5 try { throw new Error(&amp;#39;错误信息&amp;#39;); } catch (e)</description></item><item><title>Node.js 创建 webSever</title><link>https://hosea3000.github.io/nodejs/webserver/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/webserver/</guid><description>创建 webSever Node.js 创建 Http 服务器可以利用 http 包的 createServer 方法创建一个简单的 web 服务器 1 2 3 4 5 6 7 8 9 10 11 12 const http = require(&amp;#39;http&amp;#39;); const server = http.createServer((req, res) =&amp;gt; { if (req.url === &amp;#39;/ping&amp;#39;) { res.end(&amp;#39;pong&amp;#39;); } res.end(&amp;#39;hello web service&amp;#39;); }); server.listen(3000, () =&amp;gt; { console.log(&amp;#39;http</description></item><item><title>Node.js 的模块机制</title><link>https://hosea3000.github.io/nodejs/module/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/module/</guid><description>Node.js 的模块机制 Node.js 在实现模块系统时采用了 CommonJS 的模块规范。 CommonJS 的模块规范分为 3 个部分： 模块引用：通过 require()方法并传入一个模块标识来引入一个</description></item><item><title>Node.js 的版本周期</title><link>https://hosea3000.github.io/nodejs/version/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/version/</guid><description>Node.js 的版本周期 术语 CURRENT：指代最新的 Node.js 版本系列（单数）。 Active：指正在积极维护和升级的版本系列，包括向后移植非破坏性功能和改进，</description></item><item><title>Node.js 资料收集区</title><link>https://hosea3000.github.io/nodejs/common/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/common/</guid><description>Node.js 资料收集区 五月君的面试题 如何分析 Node.js 中的内存泄漏 Node.js 的特点 基于 V8 的 Javascript 服务端 Runtime 事件驱动 (event loop) 异步非阻塞 I/O (通过线程池来实现) I/O 和 CPU 完全分离, 实现非</description></item><item><title>NodeJS 自定义流的实现</title><link>https://hosea3000.github.io/nodejs/stream/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/stream/</guid><description>NodeJS 自定义流的实现 概述 常见的自定义流有四种，Readable（可读流）、Writable（可写流）、Duplex（双工流）和 Transform</description></item><item><title>npm 版本号控制</title><link>https://hosea3000.github.io/nodejs/npm/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/npm/</guid><description>npm 版本号控制 版本运算符 版本运算符指定了一定范围的版本。 主要有**~、^、-、&amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt;=、=**版本运算符。 ~</description></item><item><title>V8 的内存限制与垃圾回收</title><link>https://hosea3000.github.io/nodejs/v8/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/v8/</guid><description>V8 的内存限制与垃圾回收 V8 的内存限制 node 使用 V8 作为 javaScript 脚本引擎 v8 的内存限制和对象分配 v8 中所有 javascript 对象都是通过堆内存进行分配的 内存限制：64 位系统大约</description></item><item><title>worker_threads 工作线程</title><link>https://hosea3000.github.io/nodejs/workthred/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/workthred/</guid><description>worker_threads 工作线程 Node.js 提供了 worker_threads, 在计算密集型的情况下很好使用 以下例子展示了工作线程的基本使用以及主进程和线程之间的数据交互 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</description></item><item><title>使用 Nodemailer 发送邮件</title><link>https://hosea3000.github.io/nodejs/nodemailer/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/nodemailer/</guid><description>Node.js 使用 Nodemailer 发送邮件 Nodemailer 简介 Nodemailer 是一个简单易用的 Node.js 邮件发送组件 官网地址：https://nodemailer.com GitHub 地址：https://gith</description></item><item><title>如何在 Mac OS 下用 node 调用 C</title><link>https://hosea3000.github.io/nodejs/node-extend/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/node-extend/</guid><description>如何在 Mac OS 下用 node 调用 C 如何调用 C 代码 如何在 Mac os 编译 C 文件 使用 node-ffi 可以让 Node.js 调用 C++ 的 Library 。在 Windows 下是 dll ，在 Mac OS 下是 dylib ，Linux 则是 so 。node-ff</description></item><item><title>手动实现 Promise</title><link>https://hosea3000.github.io/nodejs/promise/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/promise/</guid><description>手动实现 Promise 参考链接: 史上最最最详细的手写 Promise 教程 在论坛上看到很多手写 promise 的帖子, 是一个常见的面试题, 自己也尝试实现一下, 同时可以帮助自己更好的理</description></item><item><title>进程和线程</title><link>https://hosea3000.github.io/nodejs/process/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/process/</guid><description>进程和线程 进程: 系统进行资源分配和调度的基本单位 线程: 程序执行的最小单位(CPU 调度的最小单位) 进程是线程的容器, 一个进程可以拥有多个线程,</description></item><item><title>面试题记录</title><link>https://hosea3000.github.io/nodejs/interview/</link><pubDate>Fri, 21 Oct 2022 02:02:33 +0800</pubDate><guid>https://hosea3000.github.io/nodejs/interview/</guid><description>面试题记录 什么是进程和线程？之间的区别？ 进程: 系统进行资源分配和调度的基本单位 线程: 程序执行的最小单位(CPU 调度的最小单位) 进程是线程的容</description></item></channel></rss>
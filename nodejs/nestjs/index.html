<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Nest.js - Hosea 的个人笔记</title><meta name=Description content="hosea的学习笔记"><meta property="og:title" content="Nest.js"><meta property="og:description" content="前言 分层是解决软件复杂度很好的方法，它能够降低耦合、增加复用。典型的 java 后端开发大多分为三层，几乎成了标准模式，但是 node 社区对于分层的讨论却很少"><meta property="og:type" content="article"><meta property="og:url" content="https://hosea3000.github.io/nodejs/nestjs/"><meta property="og:image" content="https://hosea3000.github.io/logo.png"><meta property="article:section" content="nodejs"><meta property="article:published_time" content="2022-10-21T02:02:33+08:00"><meta property="article:modified_time" content="2022-10-21T02:26:21+08:00"><meta property="og:site_name" content="hosea的学习笔记"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hosea3000.github.io/logo.png"><meta name=twitter:title content="Nest.js"><meta name=twitter:description content="前言 分层是解决软件复杂度很好的方法，它能够降低耦合、增加复用。典型的 java 后端开发大多分为三层，几乎成了标准模式，但是 node 社区对于分层的讨论却很少"><meta name=application-name content="hosea的个人笔记"><meta name=apple-mobile-web-app-title content="hosea的个人笔记"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hosea3000.github.io/nodejs/nestjs/><link rel=prev href=https://hosea3000.github.io/nodejs/exception/><link rel=next href=https://hosea3000.github.io/nodejs/operator/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Nest.js","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hosea3000.github.io\/nodejs\/nestjs\/"},"genre":"nodejs","wordcount":3201,"url":"https:\/\/hosea3000.github.io\/nodejs\/nestjs\/","datePublished":"2022-10-21T02:02:33+08:00","dateModified":"2022-10-21T02:26:21+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Hosea"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Hosea 的个人笔记">hosea</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/categories/ title=所有分类>分类 </a><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/nodejs/>Node.js </a><a class=menu-item href=/golang/ title=Golang>Golang </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Hosea 的个人笔记">hosea</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/categories/ title=所有分类>分类</a><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/nodejs/ title>Node.js</a><a class=menu-item href=/golang/ title=Golang>Golang</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page single special"><h1 class="single-title animate__animated animate__pulse animate__faster">Nest.js</h1><div class=content id=content><h2 id=前言>前言</h2><p>分层是解决软件复杂度很好的方法，它能够降低耦合、增加复用。典型的 java 后端开发大多分为三层，几乎成了标准模式，但是 node 社区对于分层的讨论却很少。node 后端是否需要分层？如何分层？本文将从个人的角度提供一些思路。</p><h2 id=是否必要分层如何分层>是否必要分层？如何分层？</h2><p>个人的结论是：如果想做一个正儿八经的 node 后台应用，一定需要分层，java 的三层架构，同样适用于 node。结构如下：
<img class=lazyload src=/svg/loading.min.svg data-src="https://segmentfault.com/img/bVbjr45?w=1170&h=430" data-srcset="https://segmentfault.com/img/bVbjr45?w=1170&h=430, https://segmentfault.com/img/bVbjr45?w=1170&h=430 1.5x, https://segmentfault.com/img/bVbjr45?w=1170&h=430 2x" data-sizes=auto alt="https://segmentfault.com/img/bVbjr45?w=1170&h=430" title=clipboard.png></p><h3 id=dao-层>dao 层</h3><p>dao(data access object)，数据访问对象，位于最下层，和数据库打交道。它的基本职责是封装数据的访问细节，为上层提供友好的数据存取接口。一般是各种数据库查询语句，缓存也可以在这层做。</p><p>无论是 nest 还是 egg，官方 demo 里都没有明确提到 dao 层，直接在 service 层操作数据库了。这对于简单的业务逻辑没问题，如果业务逻辑变得复杂，service 层的维护将会变得非常困难。业务一开始一般都很简单，它一定会向着复杂的方向演化，如果从长远考虑，一开始就应该保留 dao 层。</p><p>分享两点 dao 层的建议：</p><p><strong>1、以实体为中心定义类型描述。</strong>
后端建模的一大产出是领域实体模型，后续的业务逻辑其实就是对实体模型的增删改查。利用 ts 对类型的丰富支持，可以先将实体模型的类型描述定义出来，这将极大的方便上层业务逻辑的实现。我一般会将实体相关的类型、常量等都定义到一个文件，命名为 xxx.types.ts。定义到一个文件的好处是，编码规范好落实，书写和引用也非常方便，由于没有太多逻辑，即使文件稍微大一点，可读性也不会降低太多。</p><p>用 po 和 dto 来描述实体及其周边。po 是持久化对象和数据库的表结构一一对应；dto 数据传输对象则很灵活，可以在丰富的场景描述入参或返回值。下面是个 user 实体的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// user.types.ts
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl> * 用户持久化对象
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>export interface UserPo {
</span></span><span class=line><span class=cl>    id: number;
</span></span><span class=line><span class=cl>    name: string; // 姓名
</span></span><span class=line><span class=cl>    gender: Gender; // 性别
</span></span><span class=line><span class=cl>    desc: string; // 介绍
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl> * 新建用户传输对象
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>export interface UserAddDto {
</span></span><span class=line><span class=cl>    name: string;
</span></span><span class=line><span class=cl>    gender?: Gender;
</span></span><span class=line><span class=cl>    desc?: string;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl> * 性别
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>export enum Gender {
</span></span><span class=line><span class=cl>    Unknown,
</span></span><span class=line><span class=cl>    Male,
</span></span><span class=line><span class=cl>    Female,
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>虽然 ts 提供了强大的类型系统，如果不能总结出一套最佳实践出来，同样会越写越乱。全盘使用不是一个好的选择，因为这样会失去很多的灵活性。我们需要的是在某些必须的场景，坚持使用。</p><p><strong>2、不推荐 orm 框架</strong>
orm 的初心很好，它试图完全将对象和数据库映射自动化，让使用者不再关心数据库。过度的封装一定会带来另外一个问题——隐藏复杂度的上升。个人觉得，比起查询语句，隐藏复杂度更可怕。有很多漂亮的 orm 框架，比如 java 界曾经非常流行的 hibernate，功能非常强大，社区也很火，但实际在生产中使用的人却很少，反倒是一些简单、轻量的被大规模应用了。而且互联网应用，对性能的要求较高，因此对 sql 的控制也需要更直接和精细。很多互联网公司也不推荐使用外键，因为 db 往往是瓶颈，关系的维护可以在应用服务器做，所以 orm 框架对应关系的定义不一定能用得上。</p><p>node 社区有 typeorm，sequelizejs 等优秀的 orm 框架，个人其实并不喜欢用。我觉得比较好的是 egg mysql 插件所使用的<a href=https://github.com/ali-sdk/ali-rds target=_blank rel="noopener noreffer">ali-rds</a>。它虽然简单，却能满足我大部分的需求。所以我们需要的是一个好用的 mysql client，而不是 orm。我也造了一个类似的轮子<a href=https://github.com/vinnyguitar/bsql target=_blank rel="noopener noreffer">bsql</a>，我希望 api 的设计更加接近 sql 的语意。目前第一个版本还比较简单，核心接口已经实现，还在迭代，欢迎关注。下面是 user.dao 的示例。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>import { Injectable } from &#39;@nestjs/common&#39;;
</span></span><span class=line><span class=cl>import { BsqlClient } from &#39;bsql&#39;;
</span></span><span class=line><span class=cl>import { UserPo, UserAddDto } from &#39;./user.types&#39;;
</span></span><span class=line><span class=cl>@Injectable()
</span></span><span class=line><span class=cl>export class UserDao {
</span></span><span class=line><span class=cl>    constructor(
</span></span><span class=line><span class=cl>        private readonly db: BsqlClient,
</span></span><span class=line><span class=cl>    ) { }
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * 添加用户
</span></span><span class=line><span class=cl>     * @param userAddDto
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    async addUser(userAddDto: UserAddDto): Promise&lt;number&gt; {
</span></span><span class=line><span class=cl>        const result = await this.db.insertInto(&#39;user&#39;).values([userAddDto]);
</span></span><span class=line><span class=cl>        return result.insertId;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * 查询用户列表
</span></span><span class=line><span class=cl>     * @param limit
</span></span><span class=line><span class=cl>     * @param offset
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    async listUsers(limit: number, offset: number): Promise&lt;UserPo[]&gt; {
</span></span><span class=line><span class=cl>        return this.db.select&lt;UserPo&gt;(&#39;*&#39;).from(&#39;user&#39;).limit(limit).offset(offset);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * 查询单个用户
</span></span><span class=line><span class=cl>     * @param id
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    async getUserById(id: number): Promise&lt;UserPo&gt; {
</span></span><span class=line><span class=cl>        const [user] = await this.db.select&lt;UserPo&gt;(&#39;*&#39;).from(&#39;user&#39;).where({ id }).limit(1);
</span></span><span class=line><span class=cl>        return user;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>从广义的角度看，dao 层很像公式“程序=数据结构+算法”中的数据结构。“数据结构”的实现直接关系到上层的“算法”（业务逻辑）。</p><h3 id=service-层>service 层</h3><p>service 位于 dao 之上，使用 dao 提供的接口，也可以调用其它 service。service 层也比较简单，主要是弄清其职责和边界。</p><p><strong>1、实现业务逻辑。</strong>
service 负责业务逻辑这点毋庸置疑，核心是如何将业务逻辑抽象成接口及其粒度。service 层应该尽量提供功能相对单一的基础方法，更多的场景和变化可以在 controller 层实现。这样设计有利于 service 层的复用和稳定。</p><p><strong>2、处理异常。</strong>
service 应该合理的捕获异常并将其转化成业务异常，因为 service 层是业务逻辑层，他的调用方更关心业务逻辑进行到哪一步了，而不是一些系统异常。</p><p>在实现上，可以定义一个 business.exception.ts，里面包含常见的业务异常。当遇到业务逻辑执行不下去的问题时，抛出即可，调用方既能根据异常的类型采取行动。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// common/business.exception.ts
</span></span><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl> * 业务异常
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>export class BusinessException {
</span></span><span class=line><span class=cl>    constructor(
</span></span><span class=line><span class=cl>        private readonly code: number,
</span></span><span class=line><span class=cl>        private readonly message: string,
</span></span><span class=line><span class=cl>        private readonly detail?: string,
</span></span><span class=line><span class=cl>    ) { }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl> * 参数异常
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>export class ParamException extends BusinessException {
</span></span><span class=line><span class=cl>    constructor(message: string = &#39;参数错误&#39;, detail?: string) {
</span></span><span class=line><span class=cl>        super(400, message, detail);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl> * 权限异常
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>export class AuthException extends BusinessException {
</span></span><span class=line><span class=cl>    constructor(message: string = &#39;无权访问&#39;, detail?: string) {
</span></span><span class=line><span class=cl>        super(403, message, detail);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>对于业务异常，还需要一个兜底的地方全局捕获，因为不是每个调用方都会捕获并处理异常，兜底之后就可以记录日志（方便排查问题）同时给与一些友好的返回。在 nest 中统一捕获异常是定义一个全局 filter，代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// common/business-exception.filter.ts
</span></span><span class=line><span class=cl>import { ExceptionFilter, Catch, ArgumentsHost } from &#39;@nestjs/common&#39;;
</span></span><span class=line><span class=cl>import { BusinessException } from &#39;./business.exception&#39;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl> * 业务异常统一处理
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>@Catch(BusinessException)
</span></span><span class=line><span class=cl>export class BusinessExceptionFilter implements ExceptionFilter {
</span></span><span class=line><span class=cl>    catch(exception: BusinessException, host: ArgumentsHost) {
</span></span><span class=line><span class=cl>        const ctx = host.switchToHttp();
</span></span><span class=line><span class=cl>        const response = ctx.getResponse();
</span></span><span class=line><span class=cl>        response.json({ code: exception.code, message: exception.message });
</span></span><span class=line><span class=cl>        console.error(// tslint:disable-line
</span></span><span class=line><span class=cl>            &#39;BusinessException code:%s message:%s \n%s&#39;,
</span></span><span class=line><span class=cl>            exception.code,
</span></span><span class=line><span class=cl>            exception.message,
</span></span><span class=line><span class=cl>            exception.detail);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>// main.ts
</span></span><span class=line><span class=cl>import { NestFactory } from &#39;@nestjs/core&#39;;
</span></span><span class=line><span class=cl>import { AppModule } from &#39;./app.module&#39;;
</span></span><span class=line><span class=cl>import { BusinessExceptionFilter } from &#39;./common/business-exception.filter&#39;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>async function bootstrap() {
</span></span><span class=line><span class=cl>  const app = await NestFactory.create(AppModule);
</span></span><span class=line><span class=cl>  // 注册为全局filter
</span></span><span class=line><span class=cl>  app.useGlobalFilters(new BusinessExceptionFilter());
</span></span><span class=line><span class=cl>  await app.listen(3000);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>bootstrap();
</span></span></code></pre></td></tr></table></div></div><p><strong>3、参数校验。</strong>
dao 层设计很简单，几乎不做参数校验，同时 dao 也一般不会开放给外部直接调用，而是开放 service。所以 service 层应该做好参数校验，起到保护的作用。</p><p><strong>4、事务控制。</strong>
dao 层可以针对单个的持久化做事物控制，粒度比较小，而基于业务原则的事物处理就应该在 service 层。nest 目前貌似没有在 service 层提供事务的支持。接下来我准备做个装饰器，在 service 层提供数据库本地事物的支持。分布式事务比较复杂，有专门的方法，后面有机会再介绍。</p><h3 id=controller-层>controller 层</h3><p>controller 位于最上层，和外部系统打交道。把这层叫做“业务场景层”可能更贴切一点，它的职责是通过 service 提供的服务，实现某个特定的业务场景，并以 http、rpc 等方式暴露给外部调用。</p><p><strong>1、聚合参数</strong>
前端传参方式有多种：query、body、param。有时搞不清楚到底应该从哪区，很不方便。我一般是自定义一个@Param()装饰器，把这几种参数对象聚合到一个。实现和使用方式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// common/param.ts
</span></span><span class=line><span class=cl>import { createParamDecorator } from &#39;@nestjs/common&#39;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>export const Param = createParamDecorator((data, req) =&gt; {
</span></span><span class=line><span class=cl>    const param = { ...req.query, ...req.body, ...req.param };
</span></span><span class=line><span class=cl>    return data ? param[data] : param;
</span></span><span class=line><span class=cl>});
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// user/user.controller.ts
</span></span><span class=line><span class=cl>import { All, Controller } from &#39;@nestjs/common&#39;;
</span></span><span class=line><span class=cl>import { UserService } from &#39;./user.service&#39;;
</span></span><span class=line><span class=cl>import { UserAddDto } from &#39;./user.types&#39;;
</span></span><span class=line><span class=cl>import { Param } from &#39;../common/param&#39;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>@Controller(&#39;api/user&#39;)
</span></span><span class=line><span class=cl>export class UserController {
</span></span><span class=line><span class=cl>    constructor(private readonly userService: UserService) { }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    @All(&#39;add&#39;)
</span></span><span class=line><span class=cl>    async addUser(@Param() user: UserAddDto) {
</span></span><span class=line><span class=cl>        return this.userService.addUser(user);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    @All(&#39;list&#39;)
</span></span><span class=line><span class=cl>    async listUsers(
</span></span><span class=line><span class=cl>        @Param(&#39;pageNo&#39;) pageNo: number = 1,
</span></span><span class=line><span class=cl>        @Param(&#39;pageSize&#39;) pageSize: number = 20) {
</span></span><span class=line><span class=cl>        return this.userService.listUsers(pageNo, pageSize);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>2、统一返回结构</strong>
一个 api 调用，往往都有个固定的结构，比如有状态码和数据。可以将 controller 的返回包装一层，省去一部分样板代码。下面是用 Interceptor 的一种实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// common/result.ts
</span></span><span class=line><span class=cl>import { Injectable, NestInterceptor, ExecutionContext } from &#39;@nestjs/common&#39;;
</span></span><span class=line><span class=cl>import { Observable } from &#39;rxjs&#39;;
</span></span><span class=line><span class=cl>import { map } from &#39;rxjs/operators&#39;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>export interface Response&lt;T&gt; {
</span></span><span class=line><span class=cl>    data: T;
</span></span><span class=line><span class=cl>    code: number;
</span></span><span class=line><span class=cl>    message: string;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>@Injectable()
</span></span><span class=line><span class=cl>export class ResultInterceptor&lt;T&gt;
</span></span><span class=line><span class=cl>    implements NestInterceptor&lt;T, Response&lt;T&gt;&gt; {
</span></span><span class=line><span class=cl>    intercept(
</span></span><span class=line><span class=cl>        context: ExecutionContext,
</span></span><span class=line><span class=cl>        call$: Observable&lt;T&gt;,
</span></span><span class=line><span class=cl>    ): Observable&lt;Response&lt;T&gt;&gt; {
</span></span><span class=line><span class=cl>        return call$.pipe(map(data =&gt; ({ code: 200, data, message: &#39;success&#39; })));
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>所有的返回将会包裹在如下的结构中：
<img class=lazyload src=/svg/loading.min.svg data-src="https://segmentfault.com/img/bVbjr5a?w=560&h=384" data-srcset="https://segmentfault.com/img/bVbjr5a?w=560&h=384, https://segmentfault.com/img/bVbjr5a?w=560&h=384 1.5x, https://segmentfault.com/img/bVbjr5a?w=560&h=384 2x" data-sizes=auto alt="https://segmentfault.com/img/bVbjr5a?w=560&h=384" title=clipboard.png></p><p><strong>3、参数校验还是留给 service 层吧</strong>
nest 提供了一套针对请求参数的校验机制，功能很强大。但使用起来会稍微繁琐一点，实际上也不会有太多复杂的参数校验。个人觉得参数校验可以统一留给 service，assert 库可能就把这个事情搞定了。</p><h2 id=小结>小结</h2><p>本文讲的都是一些很小的点，大多是既有的理论。这些东西不想清楚，写代码时就会非常难受。大家可以把这里当做一个规范建议，希望能提供一些参考价值。</p><h2 id=nestjs-的执行顺序>Nest.js 的执行顺序</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>客户端请求 ---&gt; 中间件 ---&gt; 守卫 ---&gt; 拦截器之前 ---&gt; 管道 ---&gt; 控制器处理并响应 ---&gt; 拦截器之后 ---&gt; 过滤器
</span></span></code></pre></td></tr></table></div></div><h2 id=nestjs-vscode-调试>Nest.js Vscode 调试</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 使用 IntelliSense 了解相关属性。
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 悬停以查看现有属性的描述。
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nt>&#34;version&#34;</span><span class=p>:</span> <span class=s2>&#34;0.2.0&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;configurations&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;node&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;request&#34;</span><span class=p>:</span> <span class=s2>&#34;launch&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;Launch Program&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;program&#34;</span><span class=p>:</span> <span class=s2>&#34;${workspaceFolder}/src/main.ts&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;preLaunchTask&#34;</span><span class=p>:</span> <span class=s2>&#34;tsc: watch - tsconfig.build.json&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;outFiles&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;${workspaceFolder}/dist/**/*.js&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;console&#34;</span><span class=p>:</span> <span class=s2>&#34;integratedTerminal&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;skipFiles&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;${workspaceFolder}/node_modules/**/*.js&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&lt;node_internals&gt;/**/*.js&#34;</span>
</span></span><span class=line><span class=cl>      <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div></div></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://hosea3000.github.io/ target=_blank>Hosea</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a href=https://beian.miit.gov.cn/#/Integrated/index target=_blank>湘ICP备2021009721号</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/twemoji/twemoji.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},cookieconsent:{content:{dismiss:"Got it!",link:"Learn more",message:"This website uses Cookies to improve your experience."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:50,type:"lunr"},twemoji:!0}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>
[{"categories":["golang"],"content":"⚠️ golang 没有枚举类型 但是我们可以通过类型别名实现一个简单版本的 enmu package main import \"fmt\" type LogLevel int const ( INFO LogLevel = iota WARNING ERROR ) func (l LogLevel) String() string { s := []string{\"INFO\", \"WARNING\", \"ERROR\"} return s[l] } func test(level LogLevel) { fmt.Println(level) } func main() { test(ERROR) } 我们可以为类型别名实现 String() 打印的时候 golang 会默认调用，所以打印出来是我们要的字符串值。 这里只是使用了类型别名。但是实际上还是 int 类型， 方法调用者还是能传其它的 int 值进来。 暂时没有好的解决办法 不过已经很好了，从方法的签名反应出类型的枚举值 ","date":"2022-10-18","objectID":"/note/enum/:0:0","tags":null,"title":"golang中的枚举类型","uri":"/note/enum/"},{"categories":["golang"],"content":"使用 go:generate 自动生成 string 方法 如果每次都要自己写类型的string实现很容易出错，也很麻烦。 官方提供了 stringer 专门用来做这个事情 package main import \"fmt\" type Pill int const ( Placebo Pill = iota Aspirin Ibuprofen Paracetamol ) //go:generate stringer -type=Pill func main() { fmt.Println(\"Hello, world.\", Aspirin) } 执行命令 go generate会自动为你生成 pill_string.go 实现 string() 方法 ","date":"2022-10-18","objectID":"/note/enum/:0:1","tags":null,"title":"golang中的枚举类型","uri":"/note/enum/"},{"categories":["golang"],"content":"为什么 go 没有 enum 类型？ golang 的数据类型都有零值。 假如我们写了一个枚举类型的值是 [1，2，3，4，5] 那么他的零值是多少呢？ ","date":"2022-10-18","objectID":"/note/enum/:0:2","tags":null,"title":"golang中的枚举类型","uri":"/note/enum/"},{"categories":["设计模式"],"content":"单例模式就是为了保证一个类全局只有一个实例。且能够被外部使用。 ","date":"2022-10-18","objectID":"/note/4.-single/:0:0","tags":null,"title":"单例模式","uri":"/note/4.-single/"},{"categories":["设计模式"],"content":"Golang 实现 利用 lock 实现 package single import \"sync\" var lock = sync.Mutex{} type single struct {} var singles *single func NewSingle() *single { lock.Lock() defer lock.Unlock() if singles == nil { singles = \u0026single{} } return singles } 利用 Sync.Once 实现 package single import \"sync\" type single2 struct {} var single2Instance *single2 func NewSingle2() *single2 { new(sync.Once).Do(func() { single2Instance = \u0026single2{} }) return single2Instance } ","date":"2022-10-18","objectID":"/note/4.-single/:0:1","tags":null,"title":"单例模式","uri":"/note/4.-single/"},{"categories":["设计模式"],"content":" 特点： 根据工厂创建对用的产品 优点： 新增产品是新增对应的工厂和产品就好了， 不用修改原有的工厂类， 产品之间的创建逻辑解耦 缺点： 新增产品需要新增产品和工厂类， 比较麻烦， 因为一个产品对应一个类， 产品较多时类会很多 ","date":"2022-10-18","objectID":"/note/2.-factory-method/:0:0","tags":null,"title":"工厂方法模式","uri":"/note/2.-factory-method/"},{"categories":["设计模式"],"content":"Goalng 实现 package factory_method import \"fmt\" // 抽象 type AbstractProduct interface { Show() } type AbstractFactory interface { CreateProduct() *AbstractProduct } // 实现 type ProductA struct {} func (p ProductA) Show() { fmt.Println(\"ProductA Show\") } type ProductB struct {} func (p ProductB) Show() { fmt.Println(\"ProductB Show\") } type FactoryA struct {} func (f FactoryA) CreateProduct() AbstractProduct { return \u0026ProductA{} } type FactoryB struct {} func (f FactoryB) CreateProduct() AbstractProduct { return \u0026ProductB{} } // 业务 /* productA := new(FactoryA).CreateProduct() productA := new(FactoryB).CreateProduct() */ ","date":"2022-10-18","objectID":"/note/2.-factory-method/:0:1","tags":null,"title":"工厂方法模式","uri":"/note/2.-factory-method/"},{"categories":["设计模式"],"content":"TypeScript 实现 interface Product { useFunction(): void; } class ProductA implements Product { public useFunction(){ console.log(\"ProductA useFunction\") } } class ProductB implements Product { public useFunction(){ console.log(\"ProductB useFunction\") } } abstract class Factory { public abstract createProduct(): Product; } class ProductAFactory extends Factory { public createProduct(): Product { return new ProductA(); } } class ProductBFactory extends Factory { public createProduct(): Product { return new ProductB(); } } const productAFactory = new ProductAFactory() productAFactory.createProduct().useFunction() const productBFactory = new ProductBFactory() productBFactory.createProduct().useFunction() ","date":"2022-10-18","objectID":"/note/2.-factory-method/:0:2","tags":null,"title":"工厂方法模式","uri":"/note/2.-factory-method/"},{"categories":["设计模式"],"content":" 重点： 理解什么叫产品簇 特点： 多个工厂多个产品， 每个工厂都能生产多种产品， 但是每个工厂生产出来的同一个产品特点都不一样 优点： 新增产品是新增对应的工厂和产品就好了， 不用修改原有的工厂类， 产品之间的创建逻辑解耦 缺点： 所有的工厂和产品的种类都已经设计好， 难以扩展抽象工厂来生产新种类的产品 该模式重点需要理解产品簇的概念。在增加产品种类时符合开闭原则。 但是在增加产品时不符合开闭原则，反而改起来更加麻烦。 所以在实际项目中使用并不多。 ","date":"2022-10-18","objectID":"/note/3.-abstract-factory/:0:0","tags":null,"title":"抽象工厂模式","uri":"/note/3.-abstract-factory/"},{"categories":["设计模式"],"content":"Golang 的实现 package abstract_factory import \"fmt\" // 抽象 type AbstractProductA interface { Show() } type AbstractProductB interface { Show() } type AbstractFactoryA interface { CreateProductA() AbstractProductA CreateProductB() AbstractProductB } type AbstractFactoryB interface { CreateProductA() AbstractProductA CreateProductB() AbstractProductB } // 实现 type FactoryAProductA struct {} func (p FactoryAProductA) Show() { fmt.Println(\"FactoryAProductA Show\") } type FactoryAProductB struct {} func (p FactoryAProductB) Show() { fmt.Println(\"FactoryAProductB Show\") } type FactoryBProductA struct {} func (p FactoryBProductA) Show() { fmt.Println(\"FactoryBProductA Show\") } type FactoryBProductB struct {} func (p FactoryBProductB) Show() { fmt.Println(\"FactoryBProductB Show\") } type FactoryA struct {} func (f FactoryA) CreateProductA() AbstractProductA { return \u0026FactoryAProductA{} } func (f FactoryA) CreateProductB() AbstractProductB { return \u0026FactoryAProductB{} } type FactoryB struct {} func (f FactoryB) CreateProductA() AbstractProductA { return \u0026FactoryBProductA{} } func (f FactoryB) CreateProductB() AbstractProductB { return \u0026FactoryBProductB{} } // 业务 /* factoryAProductA := new(FactoryA).CreateProductA() factoryAProductB := new(FactoryA).CreateProductB() factoryBProductA := new(FactoryA).CreateProductA() factoryBProductB := new(FactoryA).CreateProductB() */ ","date":"2022-10-18","objectID":"/note/3.-abstract-factory/:0:1","tags":null,"title":"抽象工厂模式","uri":"/note/3.-abstract-factory/"},{"categories":["设计模式"],"content":"TypeScript 的实现 interface ProductA { factory: string usefulFunctionA(): void } interface ProductB { factory: string usefulFunctionB(): void } class ProductA implements ProductA { public factory: string constructor(factory: string){ this.factory = factory } usefulFunctionA() { console.log(`this is ProductA usefulFunctionA, made in ${this.factory}`) } } class ProductB implements ProductB { public factory: string constructor(factory: string){ this.factory = factory } usefulFunctionB() { console.log(`this is ProductB usefulFunctionB, made in ${this.factory}`) } } interface Factory{ factoryName: string createProductA(): ProductA createProductB(): ProductB } class FactoryA implements Factory{ factoryName = 'FactoryA' createProductA() { return new ProductA(this.factoryName) } createProductB() { return new ProductB(this.factoryName) } } class FactoryB implements Factory{ factoryName = 'FactoryB' createProductA() { return new ProductA(this.factoryName) } createProductB() { return new ProductB(this.factoryName) } } const productA: ProductA = new FactoryA().createProductA() productA.usefulFunctionA() const productB: ProductB = new FactoryA().createProductB() productB.usefulFunctionB() const productA1: ProductA = new FactoryB().createProductA() productA1.usefulFunctionA() const productB1: ProductB = new FactoryB().createProductB() productB1.usefulFunctionB() ","date":"2022-10-18","objectID":"/note/3.-abstract-factory/:0:2","tags":null,"title":"抽象工厂模式","uri":"/note/3.-abstract-factory/"},{"categories":["设计模式"],"content":" 又叫静态方法模式(因为工厂类定义了一个静态方法) 特点： 工厂类用静态方法实现产品的创建 优点： 将创建实例与使用实例分开，使用者不必关心类对象如何创建，实现了解耦 缺点： 新增产品需要修改工厂类 ","date":"2022-10-18","objectID":"/note/1.-simple-factory/:0:0","tags":null,"title":"简单工厂模式","uri":"/note/1.-simple-factory/"},{"categories":["设计模式"],"content":"Golang 实现 package simple_factory import \"fmt\" // 抽象 type AbstractProduct interface { Show() } // 实现 type ProductA struct{} func (p ProductA) Show() { fmt.Println(\"ProductA Show\") } type ProductB struct{} func (p ProductB) Show() { fmt.Println(\"ProductB Show\") } // 逻辑 type Factory struct{} func (f *Factory) CreateProduct(productType string) AbstractProduct { var product AbstractProduct switch productType { case \"ProductA\": product = \u0026ProductA{} case \"ProductB\": product = \u0026ProductB{} } return product } /* * new(Factory).CreateProduct(\"ProductA\") */ ","date":"2022-10-18","objectID":"/note/1.-simple-factory/:0:1","tags":null,"title":"简单工厂模式","uri":"/note/1.-simple-factory/"},{"categories":["设计模式"],"content":"TypeScript 实现 abstract class Product { abstract useFunction(): void } class ProductA extends Product { useFunction() { console.log(`ProductA useFunction`) } } class ProductB extends Product { useFunction() { console.log(`ProductB useFunction`) } } class SimpleFactory { public static createProduct(product: string) { switch (product) { case \"A\": return new ProductA(); case \"B\": return new ProductB(); } } } const pro: Product = SimpleFactory.createProduct('A') pro.useFunction() ","date":"2022-10-18","objectID":"/note/1.-simple-factory/:0:2","tags":null,"title":"简单工厂模式","uri":"/note/1.-simple-factory/"},{"categories":null,"content":"运行面板 docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name prtainer-test docker.io/portainer/portainer ","date":"2022-10-18","objectID":"/note/portainer/:0:1","tags":null,"title":"Portainer 的使用","uri":"/note/portainer/"},{"categories":null,"content":"安装 Agent 在Portainer的架构中，管理节点是Portainer Server，被管理节点通过部署Agent来与Server通信。 按照网络环境的不同，Portainer将Agent分为两种： Portainer Agent 和 Edge Agent。 Portainer Agent：当被管理服务器位于公网时，有公网IP，Server可以主动与其连接。此时，在被管理服务器上部署Portainer Agent来实现与Server之间的通信。 https://docs.portainer.io/v/be-2.12/start/install/agent/docker/linux Edge Agent： 当被管理服务器位于内网时，Server无法主动与其连接。此时，需要在被管理服务器上部署Edge Agent，Edge Agent会周期性的从Server中获取需要执行的任务，从而实现与Server之间的通信。 https://docs.portainer.io/v/be-2.12/start/install/agent/edge 说白了就是一个主动一个被动 Portainer Agent docker run -d -p 9001:9001 --name portainer_agent --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/docker/volumes:/var/lib/docker/volumes portainer/agent:2.12.1 ","date":"2022-10-18","objectID":"/note/portainer/:0:2","tags":null,"title":"Portainer 的使用","uri":"/note/portainer/"},{"categories":null,"content":"配置 node 在面板中增加 endpoint 之后就可以使用了 ","date":"2022-10-18","objectID":"/note/portainer/:0:3","tags":null,"title":"Portainer 的使用","uri":"/note/portainer/"},{"categories":["golang"],"content":"配置参数可变， 如何设计让未来增加方便， 好维护 package main import ( \"fmt\" \"time\" ) type Conn struct { Host string Port int Timeout time.Duration Retry int } func NewConn( host string, // 必填参数 fs ...func(*Conn), // 可选可变参数 ) *Conn { conn := \u0026Conn{ Host: host, } for _, f := range fs { f(conn) } return conn } func withPort(port int) func(*Conn) { return func(c *Conn) { c.Port = port } } func withTimeout(duration time.Duration) func(*Conn) { return func(c *Conn) { c.Timeout = duration } } func withRetry(retry int) func(*Conn) { return func(c *Conn) { c.Retry = retry } } func main() { con := NewConn( \"localhost\", withRetry(3), withPort(8080), withTimeout(2*time.Second), ) fmt.Printf(\"%#v\", con) } ","date":"2022-10-18","objectID":"/note/function/:0:0","tags":null,"title":"函数式选项模式","uri":"/note/function/"},{"categories":["golang","最佳实践"],"content":"经常会用 golang 做一些工具并开源给大家用。如果自己发版，太麻烦。 而且还要交叉编译各个平台。 在网上找到了一个golang的发布工具，只需要在本地输入一行命令就能直接编译好所有的二进制文件。并发布到 github。 goreleaser 官网地址 ","date":"2022-10-18","objectID":"/note/goreleaser/:0:0","tags":["goreleaser","github"],"title":"利用 goreleaser 发布自己的项目到 github","uri":"/note/goreleaser/"},{"categories":["golang","最佳实践"],"content":"最后的效果如下： ","date":"2022-10-18","objectID":"/note/goreleaser/:0:1","tags":["goreleaser","github"],"title":"利用 goreleaser 发布自己的项目到 github","uri":"/note/goreleaser/"},{"categories":["golang","最佳实践"],"content":"在你的项目下新建 .goreleaser.yaml 文件 # This is an example .goreleaser.yml file with some sensible defaults. # Make sure to check the documentation at https://goreleaser.com before: hooks: # You may remove this if you don't use go modules. - go mod tidy # you may remove this if you don't need go generate - go generate ./... builds: - env: - CGO_ENABLED=0 goos: - linux - windows - darwin goarch: - amd64 - arm64 gobinary: \"garble\" archives: - replacements: linux: Linux windows: Windows amd64: x86_64 darwin: MacOS checksum: name_template: 'checksums.txt' snapshot: name_template: \"{{ incpatch .Version }}-next\" changelog: sort: asc filters: exclude: - '^docs:' - '^test:' # modelines, feel free to remove those if you don't want/use them: # yaml-language-server: $schema=https://goreleaser.com/static/schema.json # vim: set ts=2 sw=2 tw=0 fo=cnqoj ","date":"2022-10-18","objectID":"/note/goreleaser/:0:2","tags":["goreleaser","github"],"title":"利用 goreleaser 发布自己的项目到 github","uri":"/note/goreleaser/"},{"categories":["golang","最佳实践"],"content":"在你的项目下新建 .github/workflows/release.yaml 文件 name: goreleaser on: push: # run only against tags tags: - '*' permissions: contents: write # packages: write # issues: write jobs: goreleaser: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: fetch-depth: 0 - run: git fetch --force --tags - uses: actions/setup-go@v3 with: go-version: '\u003e=1.19.2' cache: true # More assembly might be required: Docker logins, GPG, etc. It all depends # on your needs. - run: go install mvdan.cc/garble@latest - uses: goreleaser/goreleaser-action@v2 with: # either 'goreleaser' (default) or 'goreleaser-pro': distribution: goreleaser version: latest args: release --rm-dist env: GITHUB_TOKEN: ${{ secrets.GORELEASER_GITHUB_TOKEN }} # Your GoReleaser Pro key, if you are using the 'goreleaser-pro' # distribution: # GORELEASER_KEY: ${{ secrets.GORELEASER_GITHUB_TOKEN }} ⚠️注意： 这里需要 GITHUB_TOKEN 。需要自己提前配置。 ","date":"2022-10-18","objectID":"/note/goreleaser/:0:3","tags":["goreleaser","github"],"title":"利用 goreleaser 发布自己的项目到 github","uri":"/note/goreleaser/"},{"categories":["服务器"],"content":"安装 oh-my-zsh apt install zsh sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" // 如果速度慢可以使用 https://ghproxy.com/ ","date":"2022-10-18","objectID":"/note/%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:1","tags":["docker"],"title":"新装 Ubuntu 服务器","uri":"/note/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["服务器"],"content":"安装 tmux sudo apt install tmux ","date":"2022-10-18","objectID":"/note/%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:2","tags":["docker"],"title":"新装 Ubuntu 服务器","uri":"/note/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["服务器"],"content":"安装 node.js 1.替换源(16为node版本) curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash - 2. 安装 node sudo apt-get install -y nodejs 3. 安装 yarn curl -sL https://dl.yarnpkg.com/debian/pubkey.gpg | gpg --dearmor | sudo tee /usr/share/keyrings/yarnkey.gpg \u003e/dev/null echo \"deb [signed-by=/usr/share/keyrings/yarnkey.gpg] https://dl.yarnpkg.com/debian stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update \u0026\u0026 sudo apt-get install yarn ","date":"2022-10-18","objectID":"/note/%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:3","tags":["docker"],"title":"新装 Ubuntu 服务器","uri":"/note/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["服务器"],"content":"安装 docker 1. docker curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 2. 安装 docker-compose sudo curl -L \"https://ghproxy.com/https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version 怎么解决docker需要sudo才能运行的问题？ Create the docker group if it does not exist $ sudo groupadd docker Add your user to the docker group. $ sudo usermod -aG docker $USER Run the following command or Logout and login again and run (that doesn't work you may need to reboot your machine first) $ newgrp docker Check if docker can be run without root $ docker run hello-world Reboot if still got error $ reboot ","date":"2022-10-18","objectID":"/note/%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:4","tags":["docker"],"title":"新装 Ubuntu 服务器","uri":"/note/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]
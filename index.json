[{"categories":["Node.js"],"content":"Js 判斷對象是否為數組 ECMAScript5 中有一個現成的方法：Array.isArray() var obj = { 1: [1], 2: [2] }, arr = [1], str = '1'; Array.isArray(obj); // return false Array.isArray(arr); // return true Array.isArray(str); // return false instanceof instanceof 操作符用於判斷對象是不是類的實例。使用方法是 object instanceof Class var obj = { 1: [1], 2: [2] }, arr = [1], str = '1'; obj instanceof Array; // return false arr instanceof Array; // return true str instanceof Array; // return false 原型 所有 Javascript 對象都派生自 Object 對象，可以通過 call 方法調用 Object 的 prototype 屬性判斷對象是不是數組 var obj = { 1: [1], 2: [2] }, arr = [1], str = '1'; Object.prototype.toString.call(obj); //return \"[object Object]\" Object.prototype.toString.call(arr); //return \"[object Array]\" Object.prototype.toString.call(str); //return \"[object String]\" ","date":"2022-10-21","objectID":"/nodejs/array/:0:1","tags":null,"title":"Array","uri":"/nodejs/array/"},{"categories":["Node.js"],"content":"js 目前也有类似于 Java 和 Python 的装饰器概念, 主要写法如下 @frozen class Foo { @configurable(false) @enumerable(true) method() {} @throttle(500) expensiveMethod() {} } 目前在 Node.js 中还无法使用这个特性, 那么他是怎么实现的呢? 关键点在于 Object.defineProperty 都是用这个方法实现的 class Person { name() { return 'old name'; } } Object.defineProperty(Person.prototype, 'name', { value() { return 'new name'; }, enumerable: false, configurable: true, writable: true, }); // 相当于重新定于了Person的name方法 const p = new Person(); console.log(p.name()); 这个方式完全重新定义了 name 方法, 如果我的需求是 在原有的方法上做一点扩展, 那该怎样实现呢? class Person { constructor() { this.age = 17; } getAge() { return this.age; } } function createAgeDecorator(target, name) { const func = target[name]; // 先保存旧的方法 const ageDescroptor = { value() { const age = func.apply(this); // 调用旧的方法 if (age \u003c 18) { console.log('这个人还没有成年!'); } return age; }, enumerable: false, configurable: true, writable: true, }; Object.defineProperty(target, name, ageDescroptor); // 在类上新定义方法 } createAgeDecorator(Person.prototype, 'getAge'); // Person 类的getAge上添加装饰器 const p = new Person(); console.log(p.getAge()); 在 Person 类的 getAge 方法上增加了装饰器, 如果年龄不满 18 岁会有提示 参考链接: Javascript 中的装饰器 ","date":"2022-10-21","objectID":"/nodejs/decorator/:0:0","tags":null,"title":"decorator 装饰器","uri":"/nodejs/decorator/"},{"categories":["Node.js"],"content":"问题示例 const express = require('express'); const app = express(); app.get('/', async (req, res, next) =\u003e { throw new Error('test error'); }); app.use(async function (error, req, res, next) { console.log('will not print'); // 这里无法捕获到错误, 关键点在于action是异步方法 res.json({ message: error.message || error }); }); const server = app.listen(3000, function () { console.log('server started...'); }); 定义的错误中间件无法捕获到 action 抛出的错误, 解决办法 如下: ","date":"2022-10-21","objectID":"/nodejs/express/:0:1","tags":null,"title":"Express 错误处理中间件如何捕获 async 方法的异常?","uri":"/nodejs/express/"},{"categories":["Node.js"],"content":"解决方法一 不要直接抛错, 用 next() app.get('/', async (req, res, next) =\u003e { next(new Error('test error')); }); ","date":"2022-10-21","objectID":"/nodejs/express/:0:2","tags":null,"title":"Express 错误处理中间件如何捕获 async 方法的异常?","uri":"/nodejs/express/"},{"categories":["Node.js"],"content":"解决办法二 自定义一个 action 的处理函数 const express = require('express'); const app = express(); const asyncMiddleware = (fn) =\u003e async (req, res, next) =\u003e { try { const data = await fn(req, res, next); return data; } catch (err) { next(err); } }; app.get( '/', asyncMiddleware(async (req, res, next) =\u003e { throw new Error('test error'); }) ); app.use(async function (error, req, res, next) { console.log('will print'); res.json({ message: error.message || error }); }); const server = app.listen(3000, function () { console.log('server started...'); }); ","date":"2022-10-21","objectID":"/nodejs/express/:0:3","tags":null,"title":"Express 错误处理中间件如何捕获 async 方法的异常?","uri":"/nodejs/express/"},{"categories":["Node.js"],"content":"解决办法三 利用第三方包 express-async-errors const express = require('express'); const app = express(); require('express-async-errors'); app.get('/', async (req, res, next) =\u003e { throw new Error('test error'); }); app.use(async function (error, req, res, next) { console.log('will print'); res.json({ message: error.message || error }); }); const server = app.listen(3000, function () { const host = server.address().address; const port = server.address().port; console.log('server start', host, port); }); ","date":"2022-10-21","objectID":"/nodejs/express/:0:4","tags":null,"title":"Express 错误处理中间件如何捕获 async 方法的异常?","uri":"/nodejs/express/"},{"categories":["Node.js"],"content":"js 中 sort 数字排序问题 语法：arrayObject.sort(sortby)；参数 sortby 可选。规定排序顺序。必须是函数。 sort() 方法用于对数组的元素进行排序。默认按照字符进行排序, 就算是数字,也会先转成字符串进行排序 sortby 参数是一个 function, 比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 ","date":"2022-10-21","objectID":"/nodejs/sort/:0:0","tags":null,"title":"js 中 sort 数字排序问题","uri":"/nodejs/sort/"},{"categories":["Node.js"],"content":"用 js 中的 sort()方法排序数字(注意这里是按照字符排序的) var arr = [23, 12, 1, 34, 116, 8, 18, 37, 56, 50]; console.log(arr.sort()); // [1, 116, 12, 18, 23, 34, 37, 50, 56, 8] ","date":"2022-10-21","objectID":"/nodejs/sort/:0:1","tags":null,"title":"js 中 sort 数字排序问题","uri":"/nodejs/sort/"},{"categories":["Node.js"],"content":"自定义排序方法 const arr = [23, 12, 1, 34, 116, 8, 18, 37, 56, 50]; console.log(arr.sort((a, b) =\u003e a - b)); // [1, 8, 12, 18, 23, 34, 37, 50, 56, 116] ","date":"2022-10-21","objectID":"/nodejs/sort/:0:2","tags":null,"title":"js 中 sort 数字排序问题","uri":"/nodejs/sort/"},{"categories":["Node.js"],"content":"默认的字符排序 var arr = ['fanda', 'banner', 'find', 'zoom', 'index', 'width', 'javascript']; console.log(arr.sort()); // [\"banner\", \"fanda\", \"find\", \"index\", \"javascript\", \"width\", \"zoom\"] ","date":"2022-10-21","objectID":"/nodejs/sort/:0:3","tags":null,"title":"js 中 sort 数字排序问题","uri":"/nodejs/sort/"},{"categories":["Node.js"],"content":"1、JS 中的||符号： 运算方法： ​ 只要“||”前面为 false,不管“||”后面是 true 还是 false，都返回“||”后面的值。 ​ 只要“||”前面为 true,不管“||”后面是 true 还是 false，都返回“||”前面的值。 总结：真前假后 2、JS 中的\u0026\u0026符号： 运算方法： ​ 只要“\u0026\u0026”前面是 false，无论“\u0026\u0026”后面是 true 还是 false，结果都将返“\u0026\u0026”前面的值; ​ 只要“\u0026\u0026”前面是 true，无论“\u0026\u0026”后面是 true 还是 false，结果都将返“\u0026\u0026”后面的值; 总结：假前真后 弄懂了以上说的还应该知道： ​ js 的 6 个蛋蛋：在 js 逻辑运算中，0、”“、null、false、undefined、NaN 都会判为 false，其他都为 true。 3、位运算符：| 运算方法： ​ 两个位只要有一个为 1，那么结果都为 1。否则就为 0 4、位运算符：\u0026 运算方法： ​ 两个数值的个位分别相与，同时为 1 才得 1，只要一个为 0 就为 0。 ","date":"2022-10-21","objectID":"/nodejs/operator/:0:0","tags":null,"title":"JS 中的||符号","uri":"/nodejs/operator/"},{"categories":["Node.js"],"content":"前言 分层是解决软件复杂度很好的方法，它能够降低耦合、增加复用。典型的 java 后端开发大多分为三层，几乎成了标准模式，但是 node 社区对于分层的讨论却很少。node 后端是否需要分层？如何分层？本文将从个人的角度提供一些思路。 ","date":"2022-10-21","objectID":"/nodejs/nestjs/:1:0","tags":null,"title":"Nest.js","uri":"/nodejs/nestjs/"},{"categories":["Node.js"],"content":"是否必要分层？如何分层？ 个人的结论是：如果想做一个正儿八经的 node 后台应用，一定需要分层，java 的三层架构，同样适用于 node。结构如下： ","date":"2022-10-21","objectID":"/nodejs/nestjs/:2:0","tags":null,"title":"Nest.js","uri":"/nodejs/nestjs/"},{"categories":["Node.js"],"content":"dao 层 dao(data access object)，数据访问对象，位于最下层，和数据库打交道。它的基本职责是封装数据的访问细节，为上层提供友好的数据存取接口。一般是各种数据库查询语句，缓存也可以在这层做。 无论是 nest 还是 egg，官方 demo 里都没有明确提到 dao 层，直接在 service 层操作数据库了。这对于简单的业务逻辑没问题，如果业务逻辑变得复杂，service 层的维护将会变得非常困难。业务一开始一般都很简单，它一定会向着复杂的方向演化，如果从长远考虑，一开始就应该保留 dao 层。 分享两点 dao 层的建议： 1、以实体为中心定义类型描述。 后端建模的一大产出是领域实体模型，后续的业务逻辑其实就是对实体模型的增删改查。利用 ts 对类型的丰富支持，可以先将实体模型的类型描述定义出来，这将极大的方便上层业务逻辑的实现。我一般会将实体相关的类型、常量等都定义到一个文件，命名为 xxx.types.ts。定义到一个文件的好处是，编码规范好落实，书写和引用也非常方便，由于没有太多逻辑，即使文件稍微大一点，可读性也不会降低太多。 用 po 和 dto 来描述实体及其周边。po 是持久化对象和数据库的表结构一一对应；dto 数据传输对象则很灵活，可以在丰富的场景描述入参或返回值。下面是个 user 实体的例子： // user.types.ts /** * 用户持久化对象 */ export interface UserPo { id: number; name: string; // 姓名 gender: Gender; // 性别 desc: string; // 介绍 } /** * 新建用户传输对象 */ export interface UserAddDto { name: string; gender?: Gender; desc?: string; } /** * 性别 */ export enum Gender { Unknown, Male, Female, } 虽然 ts 提供了强大的类型系统，如果不能总结出一套最佳实践出来，同样会越写越乱。全盘使用不是一个好的选择，因为这样会失去很多的灵活性。我们需要的是在某些必须的场景，坚持使用。 2、不推荐 orm 框架 orm 的初心很好，它试图完全将对象和数据库映射自动化，让使用者不再关心数据库。过度的封装一定会带来另外一个问题——隐藏复杂度的上升。个人觉得，比起查询语句，隐藏复杂度更可怕。有很多漂亮的 orm 框架，比如 java 界曾经非常流行的 hibernate，功能非常强大，社区也很火，但实际在生产中使用的人却很少，反倒是一些简单、轻量的被大规模应用了。而且互联网应用，对性能的要求较高，因此对 sql 的控制也需要更直接和精细。很多互联网公司也不推荐使用外键，因为 db 往往是瓶颈，关系的维护可以在应用服务器做，所以 orm 框架对应关系的定义不一定能用得上。 node 社区有 typeorm，sequelizejs 等优秀的 orm 框架，个人其实并不喜欢用。我觉得比较好的是 egg mysql 插件所使用的ali-rds。它虽然简单，却能满足我大部分的需求。所以我们需要的是一个好用的 mysql client，而不是 orm。我也造了一个类似的轮子bsql，我希望 api 的设计更加接近 sql 的语意。目前第一个版本还比较简单，核心接口已经实现，还在迭代，欢迎关注。下面是 user.dao 的示例。 import { Injectable } from '@nestjs/common'; import { BsqlClient } from 'bsql'; import { UserPo, UserAddDto } from './user.types'; @Injectable() export class UserDao { constructor( private readonly db: BsqlClient, ) { } /** * 添加用户 * @param userAddDto */ async addUser(userAddDto: UserAddDto): Promise\u003cnumber\u003e { const result = await this.db.insertInto('user').values([userAddDto]); return result.insertId; } /** * 查询用户列表 * @param limit * @param offset */ async listUsers(limit: number, offset: number): Promise\u003cUserPo[]\u003e { return this.db.select\u003cUserPo\u003e('*').from('user').limit(limit).offset(offset); } /** * 查询单个用户 * @param id */ async getUserById(id: number): Promise\u003cUserPo\u003e { const [user] = await this.db.select\u003cUserPo\u003e('*').from('user').where({ id }).limit(1); return user; } } 从广义的角度看，dao 层很像公式“程序=数据结构+算法”中的数据结构。“数据结构”的实现直接关系到上层的“算法”（业务逻辑）。 ","date":"2022-10-21","objectID":"/nodejs/nestjs/:2:1","tags":null,"title":"Nest.js","uri":"/nodejs/nestjs/"},{"categories":["Node.js"],"content":"service 层 service 位于 dao 之上，使用 dao 提供的接口，也可以调用其它 service。service 层也比较简单，主要是弄清其职责和边界。 1、实现业务逻辑。 service 负责业务逻辑这点毋庸置疑，核心是如何将业务逻辑抽象成接口及其粒度。service 层应该尽量提供功能相对单一的基础方法，更多的场景和变化可以在 controller 层实现。这样设计有利于 service 层的复用和稳定。 2、处理异常。 service 应该合理的捕获异常并将其转化成业务异常，因为 service 层是业务逻辑层，他的调用方更关心业务逻辑进行到哪一步了，而不是一些系统异常。 在实现上，可以定义一个 business.exception.ts，里面包含常见的业务异常。当遇到业务逻辑执行不下去的问题时，抛出即可，调用方既能根据异常的类型采取行动。 // common/business.exception.ts /** * 业务异常 */ export class BusinessException { constructor( private readonly code: number, private readonly message: string, private readonly detail?: string, ) { } } /** * 参数异常 */ export class ParamException extends BusinessException { constructor(message: string = '参数错误', detail?: string) { super(400, message, detail); } } /** * 权限异常 */ export class AuthException extends BusinessException { constructor(message: string = '无权访问', detail?: string) { super(403, message, detail); } } 对于业务异常，还需要一个兜底的地方全局捕获，因为不是每个调用方都会捕获并处理异常，兜底之后就可以记录日志（方便排查问题）同时给与一些友好的返回。在 nest 中统一捕获异常是定义一个全局 filter，代码如下： // common/business-exception.filter.ts import { ExceptionFilter, Catch, ArgumentsHost } from '@nestjs/common'; import { BusinessException } from './business.exception'; /** * 业务异常统一处理 */ @Catch(BusinessException) export class BusinessExceptionFilter implements ExceptionFilter { catch(exception: BusinessException, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse(); response.json({ code: exception.code, message: exception.message }); console.error(// tslint:disable-line 'BusinessException code:%s message:%s \\n%s', exception.code, exception.message, exception.detail); } } // main.ts import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; import { BusinessExceptionFilter } from './common/business-exception.filter'; async function bootstrap() { const app = await NestFactory.create(AppModule); // 注册为全局filter app.useGlobalFilters(new BusinessExceptionFilter()); await app.listen(3000); } bootstrap(); 3、参数校验。 dao 层设计很简单，几乎不做参数校验，同时 dao 也一般不会开放给外部直接调用，而是开放 service。所以 service 层应该做好参数校验，起到保护的作用。 4、事务控制。 dao 层可以针对单个的持久化做事物控制，粒度比较小，而基于业务原则的事物处理就应该在 service 层。nest 目前貌似没有在 service 层提供事务的支持。接下来我准备做个装饰器，在 service 层提供数据库本地事物的支持。分布式事务比较复杂，有专门的方法，后面有机会再介绍。 ","date":"2022-10-21","objectID":"/nodejs/nestjs/:2:2","tags":null,"title":"Nest.js","uri":"/nodejs/nestjs/"},{"categories":["Node.js"],"content":"controller 层 controller 位于最上层，和外部系统打交道。把这层叫做“业务场景层”可能更贴切一点，它的职责是通过 service 提供的服务，实现某个特定的业务场景，并以 http、rpc 等方式暴露给外部调用。 1、聚合参数 前端传参方式有多种：query、body、param。有时搞不清楚到底应该从哪区，很不方便。我一般是自定义一个@Param()装饰器，把这几种参数对象聚合到一个。实现和使用方式如下： // common/param.ts import { createParamDecorator } from '@nestjs/common'; export const Param = createParamDecorator((data, req) =\u003e { const param = { ...req.query, ...req.body, ...req.param }; return data ? param[data] : param; }); // user/user.controller.ts import { All, Controller } from '@nestjs/common'; import { UserService } from './user.service'; import { UserAddDto } from './user.types'; import { Param } from '../common/param'; @Controller('api/user') export class UserController { constructor(private readonly userService: UserService) { } @All('add') async addUser(@Param() user: UserAddDto) { return this.userService.addUser(user); } @All('list') async listUsers( @Param('pageNo') pageNo: number = 1, @Param('pageSize') pageSize: number = 20) { return this.userService.listUsers(pageNo, pageSize); } } 2、统一返回结构 一个 api 调用，往往都有个固定的结构，比如有状态码和数据。可以将 controller 的返回包装一层，省去一部分样板代码。下面是用 Interceptor 的一种实现： // common/result.ts import { Injectable, NestInterceptor, ExecutionContext } from '@nestjs/common'; import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; export interface Response\u003cT\u003e { data: T; code: number; message: string; } @Injectable() export class ResultInterceptor\u003cT\u003e implements NestInterceptor\u003cT, Response\u003cT\u003e\u003e { intercept( context: ExecutionContext, call$: Observable\u003cT\u003e, ): Observable\u003cResponse\u003cT\u003e\u003e { return call$.pipe(map(data =\u003e ({ code: 200, data, message: 'success' }))); } } 所有的返回将会包裹在如下的结构中： 3、参数校验还是留给 service 层吧 nest 提供了一套针对请求参数的校验机制，功能很强大。但使用起来会稍微繁琐一点，实际上也不会有太多复杂的参数校验。个人觉得参数校验可以统一留给 service，assert 库可能就把这个事情搞定了。 ","date":"2022-10-21","objectID":"/nodejs/nestjs/:2:3","tags":null,"title":"Nest.js","uri":"/nodejs/nestjs/"},{"categories":["Node.js"],"content":"小结 本文讲的都是一些很小的点，大多是既有的理论。这些东西不想清楚，写代码时就会非常难受。大家可以把这里当做一个规范建议，希望能提供一些参考价值。 ","date":"2022-10-21","objectID":"/nodejs/nestjs/:3:0","tags":null,"title":"Nest.js","uri":"/nodejs/nestjs/"},{"categories":["Node.js"],"content":"Nest.js 的执行顺序 客户端请求 ---\u003e 中间件 ---\u003e 守卫 ---\u003e 拦截器之前 ---\u003e 管道 ---\u003e 控制器处理并响应 ---\u003e 拦截器之后 ---\u003e 过滤器 ","date":"2022-10-21","objectID":"/nodejs/nestjs/:4:0","tags":null,"title":"Nest.js","uri":"/nodejs/nestjs/"},{"categories":["Node.js"],"content":"Nest.js Vscode 调试 { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"${workspaceFolder}/src/main.ts\", \"preLaunchTask\": \"tsc: watch - tsconfig.build.json\", \"outFiles\": [\"${workspaceFolder}/dist/**/*.js\"], \"console\": \"integratedTerminal\", \"skipFiles\": [ \"${workspaceFolder}/node_modules/**/*.js\", \"\u003cnode_internals\u003e/**/*.js\" ] } ] } ","date":"2022-10-21","objectID":"/nodejs/nestjs/:5:0","tags":null,"title":"Nest.js","uri":"/nodejs/nestjs/"},{"categories":["Node.js"],"content":"Node.js 中的异常捕获 ","date":"2022-10-21","objectID":"/nodejs/exception/:1:0","tags":null,"title":"Node.js 中的异常捕获","uri":"/nodejs/exception/"},{"categories":["Node.js"],"content":"同步代码的错误处理 同步代码中的异常使用 try{}catch 结构即可捕获处理。 try { throw new Error('错误信息'); } catch (e) { console.error(e.message); } ","date":"2022-10-21","objectID":"/nodejs/exception/:1:1","tags":null,"title":"Node.js 中的异常捕获","uri":"/nodejs/exception/"},{"categories":["Node.js"],"content":"异步代码的错误处理 callback 传参 fs.mkdir('/dir', function (e) { if (e) { /*处理异常*/ console.log(e.message); } else { console.log('创建目录成功'); } }); event 方式 const events = require('events'); //创建一个事件监听对象 const emitter = new events.EventEmitter(); //监听error事件 emitter.addListener('error', function (e) { /*处理异常*/ console.log(e.message); }); //触发error事件 emitter.emit('error', new Error('出错啦')); Promise 方式 new Promise((resolve, reject) =\u003e { reject('error message'); }).catch((e) =\u003e { console.log(e.message); }); async/await 方式 function sleep() { return new Promise(function (resolve, reject) { reject('error message'); }); } async function main() { try { await sleep(); } catch (err) { console.log(err); } } main().then(); process 方式 你的 node.js 进程都应该加上这两个时间的捕获做为你的最后补救措施，但是不应该当作 On Error Resume Next（出了错误就恢复让它继续）的等价机制。 npm graceful 专门做这个事情, 也可以引用这个包 process.on('uncaughtException', function (e) { console.log(e.message); }); process.on('unhandledRejection', function (e) { console.log(e.message); }); ","date":"2022-10-21","objectID":"/nodejs/exception/:1:2","tags":null,"title":"Node.js 中的异常捕获","uri":"/nodejs/exception/"},{"categories":["Node.js"],"content":"创建 webSever Node.js 创建 Http 服务器可以利用 http 包的 createServer 方法创建一个简单的 web 服务器 const http = require('http'); const server = http.createServer((req, res) =\u003e { if (req.url === '/ping') { res.end('pong'); } res.end('hello web service'); }); server.listen(3000, () =\u003e { console.log('http start, listen on port 3000'); }); ","date":"2022-10-21","objectID":"/nodejs/webserver/:0:1","tags":null,"title":"Node.js 创建 webSever","uri":"/nodejs/webserver/"},{"categories":["Node.js"],"content":"Node.js 的模块机制 Node.js 在实现模块系统时采用了 CommonJS 的模块规范。 CommonJS 的模块规范分为 3 个部分： 模块引用：通过 require()方法并传入一个模块标识来引入一个模块的 API 到当前上下文中，如 var math = require(‘math’); 模块定义：通过 exports 对象来导出当前模块的方法或变量。模块中还存在一个 module 对象，exports 实际上是 module 的属性。在 Node 中，一个文件就是一个模块，模块内的“全局变量”对外都不可见，只有挂载在 exports 上的属性才是公开的，如 exports.add = function() {}; exports.PI = 3.1415926; 模块标识：模块标识其实就是传递给 require()方法的参数，它必须是小驼峰命名的字符串，或者是.、..开头的相对路径，或者绝对路径。它可以没有文件名后缀. 每个模块具有独立的空间，它们互不干扰，导出和引用都很简单。CommonJs 构建的这套模块导出和引入机制使得用户完全不必考虑变量污染的问题。 ","date":"2022-10-21","objectID":"/nodejs/module/:0:0","tags":null,"title":"Node.js 的模块机制","uri":"/nodejs/module/"},{"categories":["Node.js"],"content":"Node.js 的版本周期 术语 CURRENT：指代最新的 Node.js 版本系列（单数）。 Active：指正在积极维护和升级的版本系列，包括向后移植非破坏性功能和改进，解决错误以及修补安全漏洞。 Maintenance：这是一个维护的 LTS 版本系列，直到它的生命周期终止，只会在短时间内收到错误修复和安全补丁。 LTS：是 Long-Term Support 的缩写，代表 Node.js 长期支持的版本（版本号为复数）。 EOL：EOL 是 End of Life 的首字母缩写，进入到 EOL 时间线的版本，将不在维护。 ","date":"2022-10-21","objectID":"/nodejs/version/:1:0","tags":null,"title":"Node.js 的版本周期","uri":"/nodejs/version/"},{"categories":["Node.js"],"content":"版本的生命周期 让我们看下 Node.js 版本的生命周期是怎么样的？ 首先要知道每年的 4 月、10 月分别发布偶数、奇数版本 最近的一个偶数版本在 4 月份发布之后会持续 6 个月。 10 月份会发布一个奇数版本，最近的偶数版本会进入 Active LTS 版本持续时间为 18 个月，这期间几乎不会有不兼容的大功能更新，开发者也可以放心升级到 Active LTS 版本。 18 个月的 Active LTS 版本到期后，会进入 Maintenance LTS 版本，也就是进入维护期，时间为 12 个月，在这期间仅进行安全、Bug 更新。 一旦 Maintenance LTS 版本 12 个月的时间已到就会进入 EOL 版本，正式退出历史舞台。 ","date":"2022-10-21","objectID":"/nodejs/version/:1:1","tags":null,"title":"Node.js 的版本周期","uri":"/nodejs/version/"},{"categories":["Node.js"],"content":"Node.js 资料收集区 五月君的面试题 如何分析 Node.js 中的内存泄漏 ","date":"2022-10-21","objectID":"/nodejs/common/:0:0","tags":null,"title":"Node.js 资料收集区","uri":"/nodejs/common/"},{"categories":["Node.js"],"content":"Node.js 的特点 基于 V8 的 Javascript 服务端 Runtime 事件驱动 (event loop) 异步非阻塞 I/O (通过线程池来实现) I/O 和 CPU 完全分离, 实现非阻塞 I/O, 保证 Event loop 高效 ","date":"2022-10-21","objectID":"/nodejs/common/:1:0","tags":null,"title":"Node.js 资料收集区","uri":"/nodejs/common/"},{"categories":["Node.js"],"content":"async/await 异步中异常捕获的问题 ","date":"2022-10-21","objectID":"/nodejs/common/:2:0","tags":null,"title":"Node.js 资料收集区","uri":"/nodejs/common/"},{"categories":["Node.js"],"content":"问题: 在如下场景中 try/catch 是否能够成功捕获错误 async function test() { // throw new Error('Test Error'); return Promise.reject('Test Error'); } async function handle() { try { // case 1: 能捕获 const res = await test(); return res; // case 2: 能捕获 return await test(); // case 3: 不能捕获 return test(); } catch (err) { console.log('成功捕获 Error', err.toString()); } } handle() .then() .catch((err) =\u003e { console.log('未捕获到 Error', err.toString()); }); ","date":"2022-10-21","objectID":"/nodejs/common/:2:1","tags":null,"title":"Node.js 资料收集区","uri":"/nodejs/common/"},{"categories":["Node.js"],"content":"结论: 在 try 中异步方法调用前有 await 就能捕获到错误 ","date":"2022-10-21","objectID":"/nodejs/common/:2:2","tags":null,"title":"Node.js 资料收集区","uri":"/nodejs/common/"},{"categories":["Node.js"],"content":"IO 多路复用 设计高并发系统? 多线程 原理: 多线程, 每个线程处理一个请求(RPC 框架很多这样实现的), 问题: - 多线程存在上下文切换开销大的问题 - 多线程需要的内存资源比较多, 会有瓶颈 单线程 用单线程处理网络连接 怎么保证数据不丢失, DMA 用户态? 内核态? ","date":"2022-10-21","objectID":"/nodejs/common/:2:3","tags":null,"title":"Node.js 资料收集区","uri":"/nodejs/common/"},{"categories":["Node.js"],"content":"NodeJS 自定义流的实现 ","date":"2022-10-21","objectID":"/nodejs/stream/:1:0","tags":null,"title":"NodeJS 自定义流的实现","uri":"/nodejs/stream/"},{"categories":["Node.js"],"content":"概述 常见的自定义流有四种，Readable（可读流）、Writable（可写流）、Duplex（双工流）和 Transform（转换流），常见的自定义流应用有 HTTP 请求、响应，crypto 加密，进程 stdin 通信等等。 ","date":"2022-10-21","objectID":"/nodejs/stream/:1:1","tags":null,"title":"NodeJS 自定义流的实现","uri":"/nodejs/stream/"},{"categories":["Node.js"],"content":"自定义可读流 // 创建自定义可读流 const { Readable } = require('stream'); // 创建自定义可读流的类 class MyRead extends Readable { constructor() { super(); this.index = 0; } // 重写自定义的可读流的 _read 方法 // 注意这个方法会调用多次 _read() { this.index++; this.push(this.index + ''); if (this.index === 3) { this.push(null); } } } // 验证自定义可读流 let myRead = new MyRead(); myRead.on('data', (data) =\u003e { console.log(data); }); myRead.on('end', function () { console.log('读取完成'); }); // \u003cBuffer 31\u003e // \u003cBuffer 32\u003e // \u003cBuffer 33\u003e // 读取完成 我们自己写的 _read 方法会先查找并执行，在读取时使用 push 方法将数据读取出来，直到 push 的值为 null 才会停止，否则会认为没有读取完成，会继续调用 _read。 ","date":"2022-10-21","objectID":"/nodejs/stream/:1:2","tags":null,"title":"NodeJS 自定义流的实现","uri":"/nodejs/stream/"},{"categories":["Node.js"],"content":"自定义可写流 // 创建自定义可写流 const { Writable } = require(\"stream\"); // 创建自定义可写流的类 class MyWrite extends Writable { // 重写自定义的可写流的 _write 方法 _write(chunk, encoding, callback)) { callback(); // 将缓存区写入文件 } } // 验证自定义可写流 let myWrite = new MyWrite(); myWrite.write(\"hello\", \"utf8\", () =\u003e { console.log(\"hello ok\"); }); myWrite.write(\"world\", \"utf8\", () =\u003e { console.log(\"world ok\"); }); // hello ok // world ok ","date":"2022-10-21","objectID":"/nodejs/stream/:1:3","tags":null,"title":"NodeJS 自定义流的实现","uri":"/nodejs/stream/"},{"categories":["Node.js"],"content":"自定义双工流 Duplex 双工流分别具备 Readable 和 Writable 的功能，但是读和写互不影响，互不关联。 // 创建自定双工流 const { Duplex } = require(\"stream\"); // 创建自定义双工流的类 class MyDuplex extends Duplex { // 重写自定义的双工流的 _read 方法 _read() { this.push(\"123\"); this.push(null); } // 重写自定义的双工流的 _write 方法 _write(chunk, encoding, callback)) { callback(); } } // 验证自定义双工流 let myDuplex = new MyDuplex(); myDuplex.on(\"readable\", () =\u003e { console.log(myDuplex.read(1), \"----\"); }); setTimeout(() =\u003e { myDuplex.on(\"data\", data =\u003e { console.log(data, \"xxxx\"); }); }, 3000); // \u003cBuffer 31\u003e ---- // \u003cBuffer 32\u003e xxxx // \u003cBuffer 32\u003e ---- // \u003cBuffer 33\u003e xxxx 如果 readable 和 data 两种读取方式都使用默认先通过 data 事件读取，所以一般只选择一个，不要同时使用，可读流的特点是读取数据被消耗掉后就丢失了（缓存区被清空），如果非要两个都用可以加一个定时器（绝对不要这样写）。 ","date":"2022-10-21","objectID":"/nodejs/stream/:1:4","tags":null,"title":"NodeJS 自定义流的实现","uri":"/nodejs/stream/"},{"categories":["Node.js"],"content":"自定义转化流 Transform 转化流的意思是即可以当作可读流，又可以当作可写流，创建一个类名为 MyTransform，并继承 stream 中的 Transform 类，重写 _transform 方法，该方法的参数和 _write 相同。 在自定义转化流的 _transform 方法中，读取数据的 push 方法和 写入数据的 callback 都可以使用。 由此可以看出，Transform 类型可以将可读流转化为可写流，也可以将可写流转化成可读流，他的主要目的不是像其他类型的流一样负责数据的读写，而是既作为可读流又作为可写流，实现流的转化，即实现对数据的特殊处理，如 zib 模块实现的压缩流，cropo 模块实现的加密流，本质都是转化流，将转化流作为可写流，将存储文件内容的可写流通过 pipe 方法写入转化流，再将转化流作为可读流通过 pipe 方法将处理后的数据响应给浏览器。 // 创建自定义转化流 const { Transform } = require('stream'); // 创建自定义转化流的类 class MyTransform extends Transform { // 重写自定义的转化流的 _transform 方法 _transform(chunk, encoding, callback)) { console.log(chunck.toString.toUpperCase()); callback(); this.push('123'); } } // 验证自定义转化流 let myTransForm = new MyTransform(); // 使用标准输入 process.stdin.pipe(myTransForm).pipe(process.stdin); ","date":"2022-10-21","objectID":"/nodejs/stream/:1:5","tags":null,"title":"NodeJS 自定义流的实现","uri":"/nodejs/stream/"},{"categories":["Node.js"],"content":"npm 版本号控制 ","date":"2022-10-21","objectID":"/nodejs/npm/:1:0","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"版本运算符 版本运算符指定了一定范围的版本。 主要有**~、^、-、\u003c、\u003c=、\u003e、\u003e=、=**版本运算符。 ","date":"2022-10-21","objectID":"/nodejs/npm/:1:1","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"~ 版本号 —– 指定主版本号或者次版本号相同 ~ + 只含主版本 — 主版本相同； ~ + 含有次版本 — 主版本和次版本号相同。 版本范围 匹配版本 ~3 3.x 或者 3.0.0 \u003c= v \u003c 4.0.0 ~3.1 3.1.x 或者 3.1.0 \u003c= v \u003c3.2.0 ~3.1.2 3.1.2 \u003c v \u003c 3.2.0 指定的版本范围含有预发布版本，只会匹配和完整版本号相同的预发布版本。 ~3.1.3-beta.2 匹配 3.1.3-beat.3 不匹配 3.1.4-beat-2 npm i lodash@~3 # 安装 3.10.1 npm i lodash@~3.9 # 安装 3.9.3 npm i lodash@~3.9.1 # 安装 3.9.3 npm i lodash@~3.8.0 # 安装 3.8.0 ","date":"2022-10-21","objectID":"/nodejs/npm/:1:2","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"^ 版本号 — 第一个非零 版本号相同 版本范围 匹配版本 补充 ^3.1.5 3.1.5 \u003c= v \u003c 4.0.0 ^0.3.6 0.3.6 \u003c= v \u003c 0.4.0 ^0.0.2 0.0.2 \u003c= v \u003c 0.0.3 ^3.x.x 3.0.0 \u003c= v \u003c 4.0.0 版本号缺少的位置，会被 0 填充 ^4.2.x 4.2.0 \u003c= v \u003c 4.3.0 npm 安装包时，默认使用 ^ 匹配版本。 安装主版本号为 3 的最新版本： npm i lodash@^3 # 安装 3.10.1 npm i lodash@^3.9 # 安装 3.10.1 npm i lodash@^3.8.0 # 安装 3.10.1 ","date":"2022-10-21","objectID":"/nodejs/npm/:1:3","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"~ vs ^ 版本范围 含义 匹配的版本 说明 ~3.3.0 与 3.3.0 相似 3.3.0 \u003c= v \u003c 3.4.0 主版本和次版本相同 ^3.3.0 与 3.3.0 兼容 3.3.0 \u003c= v \u003c 4 主版本相同 同一个版本号，^ 能匹配的范围大些，更加激进。 例子 npm i lodash@^3.3.0 # 安装 3.10.1 npm i lodash@~3.3.0 # 安装 3.3.1 ~ 和 ≈ 差不多，可将 ~ 理解成相似，这样就分辨和理解了，~指定的是相似版本。 ^ 可理解成兼容版本。 ","date":"2022-10-21","objectID":"/nodejs/npm/:1:4","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"- 指定精确范围 版本范围 匹配版本 补充 2.0.0 - 3.2.7 2.0.0 \u003c= v \u003c= 3.2.7 - 前后有空格 0.4 - 3 0.4.0 \u003c= v \u003c= 3.0.0 缺少的版本号，被 0 填充 npm i vue@\"1 - 1.9\" # 安装 1.0.28 ","date":"2022-10-21","objectID":"/nodejs/npm/:1:5","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"版本号比较器 版本范围 匹配版本 补充 \u003c2.2.0 小于 2.2.0 的版本 \u003c=2.0.0 小于等于 2.0.0 的版本 \u003e4.2.0 大于 4.2.0 的版本 \u003e=4.2.0 大于等于 4.2.0 的版本 =4.3.0 等于 4.3.0 的版本 \\ 是转义字符。 npm i lodash@\\\u003c3.5 # 安装 3.4.0 npm i lodash@\\\u003c=3.5 # 安装 3.5.0 npm i lodash@\\\u003e3.5 # 安装 4.17.11 npm i lodash@\\\u003e=3.5 # 安装 4.17.11 npm i vue@\"\u003e1 \u003c2.3\" # 安装 2.2.6 ","date":"2022-10-21","objectID":"/nodejs/npm/:1:6","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"package-lock.json 在直接更新 package.json 和 package-loc.json 这两个文件后，npm install 是可以直接覆盖掉原先的版本的，所以在协作开发时，这两个文件如果有更新，你的开发环境应该 npm install 一下才对。 ","date":"2022-10-21","objectID":"/nodejs/npm/:2:0","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"运行原理: 如果改了 package.json，且 package.json 和 lock 文件不同，那么执行npm i时 npm 会根据 package 中的版本号以及语义含义去下载最新的包，并更新至 lock。如果两者是同一状态，那么执行npm i都会根据 lock 下载，不会理会 package 实际包的版本是否有新。 ","date":"2022-10-21","objectID":"/nodejs/npm/:2:1","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"npm-shrinkwrap.json 该文件是通过运行npm shrinkwrap命令产生的 ","date":"2022-10-21","objectID":"/nodejs/npm/:2:2","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"npm-shrinkwrap.json 与 package-lock.json 的区别与联系 从 npm 版本看 package-lock.json 是 npm5 的新特性，也不向前兼容，如果 npm 版本是 4 或以下，那还是使用 npm-shrinkwrap.json 吧 从 npm 处理机制来看 在一个项目里，如果本身不存在这两个文件，那么在运行 npm install 时，会自动生成一个 package-lock.json，或者在初始化一个项目 npm init 时，也会生成 package-lock.json，安装信息会依据该文件进行，而不是单纯按照 package.json，这两个文件的优先级都比 package.json 高 如果项目两个文件都存在，那么安装的依赖是依据 npm-shrinkwrap.json 来的，而忽略 package-lock.json 运行命令 npm shrinkwrap 后，如果项目里不存在 package-lock.json，那么会新建一个 npm-shrinkwrap.json 文件，如果存在 package-lock.json，那么会把 package-lock.json 重命名为 npm-shrinkwrap.json ","date":"2022-10-21","objectID":"/nodejs/npm/:2:3","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"版本控制最佳实践 package.json 包的更新策略不要太激进, 也不要太保守, 可以锁定前两位版本, 最后一位版本可变, 因为最后一位版本往往是修复 BUG package-lock.json 应该加入版本仓库, 这样可以保证测试的依赖库和上线时候的依赖库一致 ","date":"2022-10-21","objectID":"/nodejs/npm/:3:0","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"全局 node_modules 权限问题 first check who owns the directory ls -la /usr/local/lib/node_modules it is denying access because the node_module folder is owned by root drwxr-xr-x 3 root wheel 102 Jun 24 23:24 node_modules so this needs to be changed by changing root to your user but first run command below to check your current user How do I get the name of the active user via the command line in OS X? id -un OR whoami then change owner sudo chown -R [owner]:[owner] /usr/local/lib/node_modules OR sudo chown -R ownerName: /usr/local/lib/node_modules OR sudo chown -R $USER /usr/local/lib/node_modules ","date":"2022-10-21","objectID":"/nodejs/npm/:4:0","tags":null,"title":"npm 版本号控制","uri":"/nodejs/npm/"},{"categories":["Node.js"],"content":"V8 的内存限制与垃圾回收 ","date":"2022-10-21","objectID":"/nodejs/v8/:0:0","tags":null,"title":"V8 的内存限制与垃圾回收","uri":"/nodejs/v8/"},{"categories":["Node.js"],"content":"V8 的内存限制 node 使用 V8 作为 javaScript 脚本引擎 v8 的内存限制和对象分配 v8 中所有 javascript 对象都是通过堆内存进行分配的 内存限制：64 位系统大约 1.4G，32 位系统大约 0.7G, 当总使用内存超过 1.4G 之后就会 OOM(Out Of Memory)。进程会直接退出 为何要内存限制 表层原因为 v8 最初为浏览器设计，不太可能遇到大量的内存的场景。对于网页来说，v8 的限制已经绰绰有余 深层原因是 v8 的垃圾回收机制的限制. 1.4G V8 进行一次垃圾回收需要的时间大约是 50ms, 阻塞主线程 自定义内存限制 这两个值必须启动的时候指定, 启动后无法修改, 所以 V8 内存无法根据情况自动扩容 node --max-old-space-size=1700 test.js // 单位为MB node --max-new-space-size=1024 test.js // 单位为KB 查看内存 process.memoryUsage() { rss: 23863296, // rss是Resident Set Size的缩写，为常驻内存的总大小 heapTotal: 6057984, // 已经申请到的堆内存 heapUsed: 2523608, // 当前使用的堆内存 external: 1270913 // 堆外内存 } // 查看操作系统总内存 os.totalmem() // 查看操作系统的空闲内存 os.freemem() ","date":"2022-10-21","objectID":"/nodejs/v8/:0:1","tags":null,"title":"V8 的内存限制与垃圾回收","uri":"/nodejs/v8/"},{"categories":["Node.js"],"content":"垃圾回收 ","date":"2022-10-21","objectID":"/nodejs/v8/:0:2","tags":null,"title":"V8 的内存限制与垃圾回收","uri":"/nodejs/v8/"},{"categories":["Node.js"],"content":"新生代和老生代 V8 将内存分为两类：新生代内存空间和老生代内存空间，新生代内存空间主要用来存放存活时间较短的对象，老生代内存空间主要用来存放存活时间较长的对象。对于垃圾回收，新生代和老生代有各自不同的策略 ","date":"2022-10-21","objectID":"/nodejs/v8/:0:3","tags":null,"title":"V8 的内存限制与垃圾回收","uri":"/nodejs/v8/"},{"categories":["Node.js"],"content":"新生代的垃圾回收(Scavenge) 新生代需要清理的存活对象较少, 所以选择复制存活对象的算法 具体实现时主要采用了 Cheney 算法。Cheney 将内存空间一分为二， 一个处于使用，一个处于闲置。处于使用中的也叫作 From，处于闲置中的也叫作 To。垃圾回收的过程就是将 From 中存活的对象复制到 To 中 在垃圾回收的过程中，如果发现某个对象之前被清理过，那么会将其晋升到老生代内存空间中 当要从 From 复制一个对象到 To 空间时，如果 To 空间中的使用量已经超过了 25%，那么就将 From 中的对象直接晋升到老生代内存空间中 缺点是只是用了一半的内存, 优点是速度快 ","date":"2022-10-21","objectID":"/nodejs/v8/:0:4","tags":null,"title":"V8 的内存限制与垃圾回收","uri":"/nodejs/v8/"},{"categories":["Node.js"],"content":"老生代的垃圾回收(Mark Sweep \u0026 Mark Compact) 老生代中存活的对象较多, 需要清理的对象较少, 所以选择清楚死亡对象的算法 Mark Sweep(标记清除) 分为标记和清除两个阶段, 在标记阶段标记所有存活的对象, 在清除阶段清除所有标记的对象 缺点: 会产生内存碎片 Mark Compact(标记整理) 在整理的过程中将存活的对象往一端移动, 移动完成后, 直接清理掉边界内存 缺点: 速度慢 什么时候执行 GC 定时 GC 内存不够分配时 手动 GC 总结 V8 主要是 Mark Sweep 算法回收内存, 在空间不足以分配给新生代晋升的对象时才会采用 Mark Compact 方式进行垃圾回收 查看垃圾回收日志 // $ node --trace_gc // 全局作用域的GC arr = []; for (let i = 0; i \u003c 3000 * 10000; i++) { arr.push(i + 'test'); } arr = undefined; process.memoryUsage(); // 方法作用域的垃圾回收(连续调用两次) function test(num) { let arr = []; for (let i = 0; i \u003c 10000 * num; i++) { arr.push(i + 'test'); } arr = undefined; } process.memoryUsage(); 手动进行垃圾回收 // $ node --expose-gc global.gc(); ","date":"2022-10-21","objectID":"/nodejs/v8/:0:5","tags":null,"title":"V8 的内存限制与垃圾回收","uri":"/nodejs/v8/"},{"categories":["Node.js"],"content":"内存使用 1. 作用域 将变量声明在作用域内有利于垃圾回收, 避免使用全局变量 2. 闭包 闭包会导致垃圾回收失效, 尽量减少使用 3. 使用堆外内存 将对象以 Buffer 的形式保存, Buffer 不受 V8 内存限制 4. 使用 Stream 使用 Stream 避免一次读取过多的数据到内存(要使用 pipe) ","date":"2022-10-21","objectID":"/nodejs/v8/:0:6","tags":null,"title":"V8 的内存限制与垃圾回收","uri":"/nodejs/v8/"},{"categories":["Node.js"],"content":"内存泄露排查工具 heapdump+chrome devTools easy-monitor 以上内容主要来自\u003c深入浅出 Node.js\u003e 第五章 ","date":"2022-10-21","objectID":"/nodejs/v8/:0:7","tags":null,"title":"V8 的内存限制与垃圾回收","uri":"/nodejs/v8/"},{"categories":["Node.js"],"content":"内存打印工具 /** * 封装 print 方法输出内存占用信息 */ const print = function () { const memoryUsage = process.memoryUsage(); /** * 单位为字节格式为 MB 输出 */ const format = function (bytes) { return (bytes / 1024 / 1024).toFixed(2) + ' MB'; }; console.log( JSON.stringify({ rss: format(memoryUsage.rss), heapTotal: format(memoryUsage.heapTotal), heapUsed: format(memoryUsage.heapUsed), external: format(memoryUsage.external), }) ); }; test(){ const arr ==[] return ()=\u003e{ arr.push(1) } } const fun = test() fun() ","date":"2022-10-21","objectID":"/nodejs/v8/:0:8","tags":null,"title":"V8 的内存限制与垃圾回收","uri":"/nodejs/v8/"},{"categories":["Node.js"],"content":"worker_threads 工作线程 Node.js 提供了 worker_threads, 在计算密集型的情况下很好使用 以下例子展示了工作线程的基本使用以及主进程和线程之间的数据交互 const { Worker, isMainThread, parentPort, workerData, } = require('worker_threads'); function fibo(n) { return n \u003e 1 ? fibo(n - 1) + fibo(n - 2) : 1; } if (isMainThread) { const worker = new Worker(__filename, { workerData: 44 }); const worker2 = new Worker(__filename, { workerData: 42 }); worker.once('message', (message) =\u003e { console.log(`worker 1 res: ${message.res}`); }); worker2.once('message', (message) =\u003e { console.log(`worker 2 res: ${message.res}`); }); } else { console.log(process.pid); parentPort.postMessage({ res: fibo(workerData) }); } ","date":"2022-10-21","objectID":"/nodejs/workthred/:0:0","tags":null,"title":"worker_threads 工作线程","uri":"/nodejs/workthred/"},{"categories":["Node.js"],"content":"Node.js 使用 Nodemailer 发送邮件 ","date":"2022-10-21","objectID":"/nodejs/nodemailer/:1:0","tags":null,"title":"使用 Nodemailer 发送邮件","uri":"/nodejs/nodemailer/"},{"categories":["Node.js"],"content":"Nodemailer 简介 Nodemailer 是一个简单易用的 Node.js 邮件发送组件 官网地址：https://nodemailer.com GitHub 地址：https://github.com/nodemailer/nodemailer Nodemailer 的主要特点包括： 支持 Unicode 编码 支持 Window 系统环境 支持 HTML 内容和普通文本内容 支持附件(传送大附件) 支持 HTML 内容中嵌入图片 支持 SSL/STARTTLS 安全的邮件发送 支持内置的 transport 方法和其他插件实现的 transport 方法 支持自定义插件处理消息 支持 XOAUTH2 登录验证 ","date":"2022-10-21","objectID":"/nodejs/nodemailer/:2:0","tags":null,"title":"使用 Nodemailer 发送邮件","uri":"/nodejs/nodemailer/"},{"categories":["Node.js"],"content":"安装使用 首先，我们肯定是要下载安装 注意：Node.js v6+ npm install nodemailer --save 'use strict'; const nodemailer = require('nodemailer'); let transporter = nodemailer.createTransport({ // host: 'smtp.ethereal.email', service: 'qq', // 使用了内置传输发送邮件 查看支持列表：https://nodemailer.com/smtp/well-known/ port: 465, // SMTP 端口 secureConnection: true, // 使用了 SSL auth: { user: 'xxxxxx@qq.com', // 这里密码不是qq密码，是你设置的smtp授权码 pass: 'xxxxxx', }, }); let mailOptions = { from: '\"JavaScript之禅\" \u003cxxxxx@qq.com\u003e', // sender address to: 'xxxxxxxx@163.com', // list of receivers subject: 'Hello', // Subject line // 发送text或者html格式 // text: 'Hello world?', // plain text body html: '\u003cb\u003eHello world?\u003c/b\u003e', // html body }; // send mail with defined transport object transporter.sendMail(mailOptions, (error, info) =\u003e { if (error) { return console.log(error); } console.log('Message sent: %s', info.messageId); // Message sent: \u003c04ec7731-cc68-1ef6-303c-61b0f796b78f@qq.com\u003e }); ","date":"2022-10-21","objectID":"/nodejs/nodemailer/:3:0","tags":null,"title":"使用 Nodemailer 发送邮件","uri":"/nodejs/nodemailer/"},{"categories":["Node.js"],"content":"如何在 Mac OS 下用 node 调用 C 如何调用 C 代码 如何在 Mac os 编译 C 文件 使用 node-ffi 可以让 Node.js 调用 C++ 的 Library 。在 Windows 下是 dll ，在 Mac OS 下是 dylib ，Linux 则是 so 。node-ffi 加载 Library 是有限制的，只能处理 C 风格的 Library 。也就是函数要被放在 extern \"C\" 里。 ","date":"2022-10-21","objectID":"/nodejs/node-extend/:1:0","tags":null,"title":"如何在 Mac OS 下用 node 调用 C","uri":"/nodejs/node-extend/"},{"categories":["Node.js"],"content":"如何在 Mac OSX 中制作 dylib 和使用 dylib 1.首先是构建一个函数库 编辑 add.c int add(int a,int b) { return a+b; } int axb(int a,int b) { return a*b; } 2.编译函数库得到 libadd.dylib gcc -c add.c -o add.o //下面是linux系统时 ar rcs libadd.a add.o //下面是Mac OSX gcc add.o -dynamiclib -current_version 1.0 -o libadd.dylib ","date":"2022-10-21","objectID":"/nodejs/node-extend/:1:1","tags":null,"title":"如何在 Mac OS 下用 node 调用 C","uri":"/nodejs/node-extend/"},{"categories":["Node.js"],"content":"node-ffi 调用 C 编译的文件 var ref = require('ref'); var ffi = require('ffi'); var intPtr = ref.refType(ref.types.int); // 创建一个 int 指针类型 var lib = ffi.Library('libadd', { add: ['int', ['int', 'int']], axb: ['int', ['int', 'int']], }); let sum = lib.add(1, 2); console.log(`1 + 2 = ${sum}`); let res = lib.axb(3, 3); console.log(`3 * 3 = ${res}`); ","date":"2022-10-21","objectID":"/nodejs/node-extend/:1:2","tags":null,"title":"如何在 Mac OS 下用 node 调用 C","uri":"/nodejs/node-extend/"},{"categories":["Node.js"],"content":"手动实现 Promise 参考链接: 史上最最最详细的手写 Promise 教程 在论坛上看到很多手写 promise 的帖子, 是一个常见的面试题, 自己也尝试实现一下, 同时可以帮助自己更好的理解 Promise. ","date":"2022-10-21","objectID":"/nodejs/promise/:0:0","tags":null,"title":"手动实现 Promise","uri":"/nodejs/promise/"},{"categories":["Node.js"],"content":"基本实现 Promise 是一个类 new Promise 时，会返回一个 promise 的对象，它会传一个执行器（executor），这个执行器是立即执行的 另外每个 promise 实例上都会有一个 then 方法，参数分别是成功（有成功的值）和失败（有失败的原用）两个方法 promise 有三个状态：成功态(fulfilled)，失败态(rejected)，等待态(pending)。 默认状态是等待态，等待态可以变成成功态或失败态 一旦成功或失败就不能再变会其他状态了 知道这些就可以先简单实现一下了 class PromiseA { constructor(exec) { // ['pending', 'fulfilled', 'rejected'] this.state = 'pending'; this.value = undefined; this.reason = undefined; const resolve = (value) =\u003e { if (this.state === 'pending') { this.value = value; this.state = 'fulfilled'; } }; const reject = (reason) =\u003e { if (this.state === 'pending') { this.reason = reason; this.state = 'rejected'; } }; try { exec(resolve, reject); } catch (err) { reject(err); } } then(onFulfilled, onRejected) { if (this.state === 'fulfilled') { onFulfilled(this.value); } if (this.state === 'rejected') { onRejected(this.reason); } } } const a = new PromiseA((resolve) =\u003e { resolve(1); }); a.then( (res) =\u003e { console.log(res); console.log('end'); }, (err) =\u003e { console.log(err); } ); ","date":"2022-10-21","objectID":"/nodejs/promise/:1:0","tags":null,"title":"手动实现 Promise","uri":"/nodejs/promise/"},{"categories":["Node.js"],"content":"异步调用 上面简单的实现了 Promise, 但是当 resolve 在 setTomeout 内执行，调用 then 时 state 还是 pending 等待状态, 这样上面的实现就不好用了. 解决办法是新建两个数组, 用来保存成功或者失败的执行函数, 当 Promise 不再为 pending 状态时调用他们. (为什是数组? 因为 Promise 可以多次调用 then ) // 多个then的情况 const p = new Promise(); p.then(); p.then(); // 增加异步调用的实现 class PromiseA { constructor(exec) { // ['pending', 'fulfilled', 'rejected'] this.state = 'pending'; this.value = undefined; this.reason = undefined; // 成功存放的数组 this.onResolvedCallbacks = []; // 失败存放法数组 this.onRejectedCallbacks = []; const resolve = (value) =\u003e { if (this.state === 'pending') { this.value = value; this.state = 'fulfilled'; this.onResolvedCallbacks.forEach((fn) =\u003e fn()); } }; const reject = (reason) =\u003e { if (this.state === 'pending') { this.reason = reason; this.state = 'rejected'; this.onRejectedCallbacks.forEach((fn) =\u003e fn()); } }; try { exec(resolve, reject); } catch (err) { reject(err); } } then(onFulfilled, onRejected) { // 当状态state为pending时 if (this.state === 'pending') { // onFulfilled传入到成功数组 this.onResolvedCallbacks.push(() =\u003e { onFulfilled(this.value); }); // onRejected传入到失败数组 this.onRejectedCallbacks.push(() =\u003e { onRejected(this.reason); }); } if (this.state === 'fulfilled') { onFulfilled(this.value); } if (this.state === 'rejected') { onRejected(this.reason); } } } ","date":"2022-10-21","objectID":"/nodejs/promise/:1:1","tags":null,"title":"手动实现 Promise","uri":"/nodejs/promise/"},{"categories":["Node.js"],"content":"链式调用 new Promise().then().then() 这就是链式调用, 实现链式调用的主要作用就是可以解决回调地狱 1 为了达成链式，我们默认在第一个 then 里返回一个 promise。就是在 then 里面返回一个新的 promise, 称为 promise2： 将这个 promise2 返回的值传递到下一个 then 中 如果返回一个普通的值，则将普通的值传递给下一个 then 中 class PromiseA { constructor(exec) { // ['pending', 'fulfilled', 'rejected'] this.state = 'pending'; this.value = undefined; this.reason = undefined; // 成功存放的数组 this.onResolvedCallbacks = []; // 失败存放法数组 this.onRejectedCallbacks = []; const resolve = (value) =\u003e { if (this.state === 'pending') { this.value = value; this.state = 'fulfilled'; this.onResolvedCallbacks.forEach((fn) =\u003e fn()); } }; const reject = (reason) =\u003e { if (this.state === 'pending') { this.reason = reason; this.state = 'rejected'; this.onRejectedCallbacks.forEach((fn) =\u003e fn()); } }; try { exec(resolve, reject); } catch (err) { reject(err); } } then(onFulfilled, onRejected) { const promise2 = new PromiseA((resolve, reject) =\u003e { // 当状态state为pending时 if (this.state === 'pending') { // onFulfilled传入到成功数组 this.onResolvedCallbacks.push(() =\u003e { const x = onFulfilled(this.value); // resolvePromise函数，处理自己return的promise和默认的promise2的关系 resolvePromise(promise2, x, resolve, reject); }); // onRejected传入到失败数组 this.onRejectedCallbacks.push(() =\u003e { const x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); }); } if (this.state === 'fulfilled') { const x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); } if (this.state === 'rejected') { const x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); } }); return promise2; } } 实现 resolvePromise 函数 Otherwise, if x is an object or function,Let then be x.then x 不能是 null x 是普通值 直接 resolve(x) x 是对象或者函数（包括 promise），let then = x.then function resolvePromise(promise2, x, resolve, reject) { // 循环引用报错 if (x === promise2) { // reject报错 return reject(new TypeError('Chaining cycle detected for promise')); } // 防止多次调用 let called; // x不是null 且x是对象或者函数 if (x != null \u0026\u0026 (typeof x === 'object' || typeof x === 'function')) { try { // A+规定，声明then = x的then方法 const { then } = x; // 如果then是函数，就默认是promise了 if (typeof then === 'function') { // 就让then执行 第一个参数是this 后面是成功的回调 和 失败的回调 then.call( (x, y) =\u003e { // 成功和失败只能调用一个 if (called) return; called = true; // resolve的结果依旧是promise 那就继续解析 resolvePromise(promise2, y, resolve, reject); }, (err) =\u003e { // 成功和失败只能调用一个 if (called) return; called = true; reject(err); // 失败了就失败了 } ); } else { resolve(x); // 直接成功即可 } } catch (e) { // 也属于失败 if (called) return; called = true; // 取then出错了那就不要在继续执行了 reject(e); } } else { resolve(x); } } ","date":"2022-10-21","objectID":"/nodejs/promise/:1:2","tags":null,"title":"手动实现 Promise","uri":"/nodejs/promise/"},{"categories":["Node.js"],"content":"进程和线程 进程: 系统进行资源分配和调度的基本单位 线程: 程序执行的最小单位(CPU 调度的最小单位) 进程是线程的容器, 一个进程可以拥有多个线程, 每个进程都拥有自己的独立空间地址、数据栈 一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享 ","date":"2022-10-21","objectID":"/nodejs/process/:0:1","tags":null,"title":"进程和线程","uri":"/nodejs/process/"},{"categories":["Node.js"],"content":"Javascript 的单线程 Javascript 就是属于单线程，程序顺序执行，可以想象一下队列，前面一个执行完之后，后面才可以执行，当你在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。你如果采用 Javascript 进行编码时候，请尽可能的使用异步操作。 CPU 计算阻塞的例子 const computation = () =\u003e { let sum = 0; console.info('计算开始'); console.time('计算耗时'); for (let i = 0; i \u003c 1e10; i += 1) { sum += i; } console.info('计算结束'); console.timeEnd('计算耗时'); return sum; }; 因为上面的例子是 CPU 计算, 所以耗时时间比较长, 下面拿这个方法来测试 CPU 计算阻塞 WEB 服务的例子 // compute.js const computation = () =\u003e { let sum = 0; console.info('计算开始'); console.time('计算耗时'); for (let i = 0; i \u003c 1e10; i += 1) { sum += i; } console.info('计算结束'); console.timeEnd('计算耗时'); return sum; }; module.exports = { computation }; 再启用一个 web 服务 // index.js const http = require('http'); const { computation } = require('./compute'); const server = http.createServer((req, res) =\u003e { if (req.url === '/compute') { computation(); res.end('compute ok'); } if (req.url === '/ping') { res.end('req pong'); } }); server.listen(3000, () =\u003e { console.log('http start, listen on port 3000'); }); 启动服务开始测试: 访问链接: http://localhost:3000/ping 会很快得到服务器响应 req pong 访问链接: http://localhost:3000/compute 服务器开始计算, 短时间内无响应 再次访问链接: http://localhost:3000/ping 也会被卡主 等待链接: http://localhost:3000/compute 计算完成, 正确返回 再次访问链接: http://localhost:3000/ping 能正常访问 之前我一直有一个误区, 认为将这些计算耗时的操作异步去执行就不会阻塞WEB服务. 显然这样是错误的认知, 这是将异步和非阻塞两个概念弄混了. 异步调用这个方法, 只会改变计算的时间片(也就是在不同的事件循环中执行而已), 而计算还是在主线程上执行. 结论: Node.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。但是不合适CPU密集的场景 ","date":"2022-10-21","objectID":"/nodejs/process/:0:2","tags":null,"title":"进程和线程","uri":"/nodejs/process/"},{"categories":["Node.js"],"content":"多进程 在 CPU 密集型的业务场景下, 单进程就不适用了, 可以考虑多进程 针对上一个问题可以考虑再起一个进程去执行计算, 等到计算完成通知主进程 // compute.js const computation = () =\u003e { let sum = 0; console.info('计算开始'); console.time('计算耗时'); for (let i = 0; i \u003c 1e10; i += 1) { sum += i; } console.info('计算结束'); console.timeEnd('计算耗时'); return sum; }; process.on('message', (msg) =\u003e { console.log(msg, 'process.pid', process.pid); // 子进程id const sum = computation(); // 如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息 process.send(sum); }); 主进程开启一个 http 服务, 当需要计算的请求进来是 fork 一个子进程计算, 计算完成返回给客户端, 其他请求不影响, 不会阻塞服务器 const http = require('http'); const { fork } = require('child_process'); const server = http.createServer((req, res) =\u003e { if (req.url === '/compute') { const childProcess = fork('./compute'); childProcess.send('开启一个新的子进程'); // 当一个子进程使用 process.send() 发送消息时会触发 'message' 事件 childProcess.on('message', (sum) =\u003e { res.end(`Sum is ${sum}`); childProcess.kill(); }); // 子进程监听到一些错误消息退出 childProcess.on('close', (code, signal) =\u003e { console.log( `收到close事件，子进程收到信号 ${signal} 而终止，退出码 ${code}` ); childProcess.kill(); res.end('compute ok'); }); } if (req.url === '/ping') { res.end('req pong'); } }); server.listen(3000, () =\u003e { console.log('http start, listen on port 3000'); }); 这样子实现的差别就是: compute 接口等待服务器计算完成的响应时, ping 接口能够正确响应, 不收影响 多线程的代价还在于创建新的线程和执行期上下文线程的切换开销，由于每创建一个线程就会占用一定的内存，当应用程序并发大了之后，内存将会很快耗尽。类似于上面单线程模型中例举的例子，需要一定的计算会造成当前线程阻塞的，还是推荐使用多线程来处理 ","date":"2022-10-21","objectID":"/nodejs/process/:0:3","tags":null,"title":"进程和线程","uri":"/nodejs/process/"},{"categories":["Node.js"],"content":"Node.js 的多进程 Node.js 是 Javascript 在服务端的运行环境，构建在 chrome 的 V8 引擎之上，基于事件驱动、非阻塞 I/O 模型，充分利用操作系统提供的异步 I/O 进行多任务的执行，适合于 I/O 密集型的应用场景. 针对于多核 CPU 的服务器, 如果只启用一个进程,无疑是浪费了机器的性能. 多核 CPU 系统之上，可以用过 child_process.fork 开启多个进程（Node.js 在 v0.8 版本之后新增了 Cluster 来实现多进程架构） ，即 多进程 + 单线程 模式。 注意：开启多进程不是为了解决高并发，主要是解决了单进程模式下 Node.js CPU 利用率不足的情况，充分利用多核 CPU 的性能。 创建进程的方式 child_process.spawn()：适用于返回大量数据，例如图像处理，二进制数据处理。 child_process.exec()：适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。 child_process.execFile()：类似 child_process.exec()，区别是不能通过 shell 来执行，不支持像 I/O 重定向和文件查找这样的行为 child_process.fork()： 衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置。 const { spawn, exec, execFile, fork } = require('child_process'); spawn('ls', ['-l'], { cwd: '/usr' }); exec('node -v', (error, stdout, stderr) =\u003e { console.log({ error, stdout, stderr }); // { error: null, stdout: 'v8.5.0\\n', stderr: '' } }); execFile('node', ['-v'], (error, stdout, stderr) =\u003e { console.log({ error, stdout, stderr }); // { error: null, stdout: 'v8.5.0\\n', stderr: '' } }); const childFork = fork('./http-server.js'); console.log(childFork.pid); // process.pid: 57252 ","date":"2022-10-21","objectID":"/nodejs/process/:0:4","tags":null,"title":"进程和线程","uri":"/nodejs/process/"},{"categories":["Node.js"],"content":"创建多进程的 web 服务器 主进程 master.js 主要处理以下逻辑： 创建一个 server 并监听 3000 端口。 根据系统 cpus 开启多个子进程 通过子进程对象的 send 方法发送消息到子进程进行通信 在主进程中监听了子进程的变化，如果是自杀信号重新启动一个工作进程。 主进程在监听到退出消息的时候，先退出子进程在退出主进程 const cpus = require('os').cpus(); const { fork } = require('child_process'); const server = require('net').createServer(); server.listen(3000); process.title = 'node-master'; const workers = {}; function createWorker() { const worker = fork('./worker.js'); worker.on('message', (message) =\u003e { if (message.act === 'suicide') { createWorker(); } }); worker.on('exit', (code, signal) =\u003e { console.log('worker process exited, code: %s signal: %s', code, signal); delete workers[worker.pid]; }); worker.send('server', server); workers[worker.pid] = worker; console.log( 'worker process created, pid: %s ppid: %s', worker.pid, process.pid ); } for (let i = 0; i \u003c cpus.length; i += 1) { createWorker(); } function close(code) { console.log('进程退出！', code); if (code !== 0) { for (const pid of Object.keys(workers)) { console.log('master process exited, kill worker pid: ', pid); workers[pid].kill('SIGINT'); } } process.exit(0); } process.once('SIGINT', close.bind(this, 'SIGINT')); // kill(2) Ctrl-C process.once('SIGQUIT', close.bind(this, 'SIGQUIT')); // kill(3) Ctrl-\\ process.once('SIGTERM', close.bind(this, 'SIGTERM')); // kill(15) default process.once('exit', close.bind(this)); 工作进程 worker.js 子进程处理逻辑如下： 创建一个 server 对象，注意这里最开始并没有监听 3000 端口 通过 message 事件接收主进程 send 方法发送的消息 监听 uncaughtException 事件，捕获未处理的异常，发送自杀信息由主进程重建进程，子进程在链接关闭之后退出 const http = require('http'); const server = http.createServer((req, res) =\u003e { res.writeHead(200, { 'Content-Type': 'text/plan', }); res.end(`I am worker, pid: ${process.pid}, ppid: ${process.ppid}`); throw new Error('worker process exception!'); // 测试异常进程退出、重建 }); let worker; process.title = 'worker-node'; process.on('message', (message, sendHandle) =\u003e { if (message === 'server') { worker = sendHandle; worker.on('connection', (socket) =\u003e { server.emit('connection', socket); }); } }); process.on('uncaughtException', (err) =\u003e { console.log(err); process.send({ act: 'suicide' }); worker.close(() =\u003e { process.exit(1); }); }); 执行结果 创建了 5 个进程, 一个 master 和 4 个 worker worker process created, pid: 57612 ppid: 57611 worker process created, pid: 57613 ppid: 57611 worker process created, pid: 57614 ppid: 57611 worker process created, pid: 57615 ppid: 57611 这里有 2 个问题 问题一: 多个进程都需要监听同一个端口, 怎么实现的? 只有主进程监听了端口, 其他进程只是开启了 HTTP 服务, 没有监听端口, 这完全是可以的 问题二: master 进程怎么将用户请求传递给 worker 进程? 当 master 进程接收到用户请求后会接受到一个connection事件, 这时候 master 进程会触发 worker 的connection事件, 推荐阅读: 源码解析 Node.js 中 cluster 模块的主要功能实现 ","date":"2022-10-21","objectID":"/nodejs/process/:0:5","tags":null,"title":"进程和线程","uri":"/nodejs/process/"},{"categories":["Node.js"],"content":"守护进程 守护进程运行在后台不受终端的影响. 守护的意思是说可以守护 web 服务进程不被中断, 如果被中断会再启动一个进程替代 创建子进程 在子进程中创建新会话（调用系统函数 setsid） 改变子进程工作目录（如：“/” 或 “/usr/ 等） 父进程终止 // index.js const { spawn } = require('child_process'); const startDaemon = () =\u003e { const daemon = spawn('node', ['./daemon.js'], { cwd: './', detached: true, stdio: 'ignore', }); console.log( '守护进程开启 父进程 pid: %s, 守护进程 pid: %s', process.pid, daemon.pid ); daemon.unref(); }; startDaemon(); 开启一个子进程, 每 10 秒写入一条日志 // daemon.js const fs = require('fs'); const { Console } = require('console'); // custom simple logger const logger = new Console( fs.createWriteStream('./stdout.log'), fs.createWriteStream('./stderr.log') ); setInterval(() =\u003e { logger.log('daemon pid: ', process.pid, ', ppid: ', process.ppid); }, 1000 * 10); 测试结果: 主进程执行完会退出 子进程还在执行, 每 10 秒写入一条日志 ","date":"2022-10-21","objectID":"/nodejs/process/:0:6","tags":null,"title":"进程和线程","uri":"/nodejs/process/"},{"categories":["Node.js"],"content":"面试题记录 ","date":"2022-10-21","objectID":"/nodejs/interview/:0:0","tags":null,"title":"面试题记录","uri":"/nodejs/interview/"},{"categories":["Node.js"],"content":"什么是进程和线程？之间的区别？ 进程: 系统进行资源分配和调度的基本单位 线程: 程序执行的最小单位(CPU 调度的最小单位) 进程是线程的容器, 一个进程可以拥有多个线程, 每个进程都拥有自己的独立空间地址、数据栈 一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享 ","date":"2022-10-21","objectID":"/nodejs/interview/:0:1","tags":null,"title":"面试题记录","uri":"/nodejs/interview/"},{"categories":["Node.js"],"content":"什么是孤儿进程？ 父进程创建子进程之后，父进程退出了，但是父进程对应的一个或多个子进程还在运行，这些子进程会被系统的 init 进程收养，对应的进程 ppid 为 1，这就是孤儿进程 ","date":"2022-10-21","objectID":"/nodejs/interview/:0:2","tags":null,"title":"面试题记录","uri":"/nodejs/interview/"},{"categories":["Node.js"],"content":"Node.js 是单线程还是多线程？进一步会提问为什么是单线程？ Javascript 是单线程的，但是做为其在服务端运行环境的 Node.js 并非是单线程的。 Javascript 在设计的时候只希望有一个线程来操作 DOM, 如果多个会乱套 ","date":"2022-10-21","objectID":"/nodejs/interview/:0:3","tags":null,"title":"面试题记录","uri":"/nodejs/interview/"},{"categories":["Node.js"],"content":"如何让一个 js 文件在 Linux 下成为一个可执行命令程序? 新建 hello.js 文件，头部须加上 #!/usr/bin/env node，表示当前脚本使用 Node.js 进行解析 赋予文件可执行权限 chmod +x /${dir}/hello.js，目录自定义 在 /usr/local/bin 目录下创建一个软链文件 sudo ln -s /${dir}/hello.js /usr/local/bin/hello，文件名就是我们在终端使用的名字 终端执行 hello 相当于输入 node hello.js ","date":"2022-10-21","objectID":"/nodejs/interview/:0:4","tags":null,"title":"面试题记录","uri":"/nodejs/interview/"},{"categories":["golang"],"content":"⚠️ golang 没有枚举类型 但是我们可以通过类型别名实现一个简单版本的 enmu package main import \"fmt\" type LogLevel int const ( INFO LogLevel = iota WARNING ERROR ) func (l LogLevel) String() string { s := []string{\"INFO\", \"WARNING\", \"ERROR\"} return s[l] } func test(level LogLevel) { fmt.Println(level) } func main() { test(ERROR) } 我们可以为类型别名实现 String() 打印的时候 golang 会默认调用，所以打印出来是我们要的字符串值。 这里只是使用了类型别名。但是实际上还是 int 类型， 方法调用者还是能传其它的 int 值进来。 暂时没有好的解决办法 不过已经很好了，从方法的签名反应出类型的枚举值 ","date":"2022-10-18","objectID":"/golang/enum/:0:0","tags":null,"title":"golang中的枚举类型","uri":"/golang/enum/"},{"categories":["golang"],"content":"使用 go:generate 自动生成 string 方法 如果每次都要自己写类型的string实现很容易出错，也很麻烦。 官方提供了 stringer 专门用来做这个事情 package main import \"fmt\" type Pill int const ( Placebo Pill = iota Aspirin Ibuprofen Paracetamol ) //go:generate stringer -type=Pill func main() { fmt.Println(\"Hello, world.\", Aspirin) } 执行命令 go generate会自动为你生成 pill_string.go 实现 string() 方法 ","date":"2022-10-18","objectID":"/golang/enum/:0:1","tags":null,"title":"golang中的枚举类型","uri":"/golang/enum/"},{"categories":["golang"],"content":"为什么 go 没有 enum 类型？ golang 的数据类型都有零值。 假如我们写了一个枚举类型的值是 [1，2，3，4，5] 那么他的零值是多少呢？ ","date":"2022-10-18","objectID":"/golang/enum/:0:2","tags":null,"title":"golang中的枚举类型","uri":"/golang/enum/"},{"categories":["设计模式"],"content":"单例模式就是为了保证一个类全局只有一个实例。且能够被外部使用。 ","date":"2022-10-18","objectID":"/4.-single/:0:0","tags":null,"title":"单例模式","uri":"/4.-single/"},{"categories":["设计模式"],"content":"Golang 实现 利用 lock 实现 package single import \"sync\" var lock = sync.Mutex{} type single struct {} var singles *single func NewSingle() *single { lock.Lock() defer lock.Unlock() if singles == nil { singles = \u0026single{} } return singles } 利用 Sync.Once 实现 package single import \"sync\" type single2 struct {} var single2Instance *single2 func NewSingle2() *single2 { new(sync.Once).Do(func() { single2Instance = \u0026single2{} }) return single2Instance } ","date":"2022-10-18","objectID":"/4.-single/:0:1","tags":null,"title":"单例模式","uri":"/4.-single/"},{"categories":["设计模式"],"content":" 特点： 根据工厂创建对用的产品 优点： 新增产品是新增对应的工厂和产品就好了， 不用修改原有的工厂类， 产品之间的创建逻辑解耦 缺点： 新增产品需要新增产品和工厂类， 比较麻烦， 因为一个产品对应一个类， 产品较多时类会很多 ","date":"2022-10-18","objectID":"/2.-factory-method/:0:0","tags":null,"title":"工厂方法模式","uri":"/2.-factory-method/"},{"categories":["设计模式"],"content":"Goalng 实现 package factory_method import \"fmt\" // 抽象 type AbstractProduct interface { Show() } type AbstractFactory interface { CreateProduct() *AbstractProduct } // 实现 type ProductA struct {} func (p ProductA) Show() { fmt.Println(\"ProductA Show\") } type ProductB struct {} func (p ProductB) Show() { fmt.Println(\"ProductB Show\") } type FactoryA struct {} func (f FactoryA) CreateProduct() AbstractProduct { return \u0026ProductA{} } type FactoryB struct {} func (f FactoryB) CreateProduct() AbstractProduct { return \u0026ProductB{} } // 业务 /* productA := new(FactoryA).CreateProduct() productA := new(FactoryB).CreateProduct() */ ","date":"2022-10-18","objectID":"/2.-factory-method/:0:1","tags":null,"title":"工厂方法模式","uri":"/2.-factory-method/"},{"categories":["设计模式"],"content":"TypeScript 实现 interface Product { useFunction(): void; } class ProductA implements Product { public useFunction(){ console.log(\"ProductA useFunction\") } } class ProductB implements Product { public useFunction(){ console.log(\"ProductB useFunction\") } } abstract class Factory { public abstract createProduct(): Product; } class ProductAFactory extends Factory { public createProduct(): Product { return new ProductA(); } } class ProductBFactory extends Factory { public createProduct(): Product { return new ProductB(); } } const productAFactory = new ProductAFactory() productAFactory.createProduct().useFunction() const productBFactory = new ProductBFactory() productBFactory.createProduct().useFunction() ","date":"2022-10-18","objectID":"/2.-factory-method/:0:2","tags":null,"title":"工厂方法模式","uri":"/2.-factory-method/"},{"categories":["设计模式"],"content":" 重点： 理解什么叫产品簇 特点： 多个工厂多个产品， 每个工厂都能生产多种产品， 但是每个工厂生产出来的同一个产品特点都不一样 优点： 新增产品是新增对应的工厂和产品就好了， 不用修改原有的工厂类， 产品之间的创建逻辑解耦 缺点： 所有的工厂和产品的种类都已经设计好， 难以扩展抽象工厂来生产新种类的产品 该模式重点需要理解产品簇的概念。在增加产品种类时符合开闭原则。 但是在增加产品时不符合开闭原则，反而改起来更加麻烦。 所以在实际项目中使用并不多。 ","date":"2022-10-18","objectID":"/3.-abstract-factory/:0:0","tags":null,"title":"抽象工厂模式","uri":"/3.-abstract-factory/"},{"categories":["设计模式"],"content":"Golang 的实现 package abstract_factory import \"fmt\" // 抽象 type AbstractProductA interface { Show() } type AbstractProductB interface { Show() } type AbstractFactoryA interface { CreateProductA() AbstractProductA CreateProductB() AbstractProductB } type AbstractFactoryB interface { CreateProductA() AbstractProductA CreateProductB() AbstractProductB } // 实现 type FactoryAProductA struct {} func (p FactoryAProductA) Show() { fmt.Println(\"FactoryAProductA Show\") } type FactoryAProductB struct {} func (p FactoryAProductB) Show() { fmt.Println(\"FactoryAProductB Show\") } type FactoryBProductA struct {} func (p FactoryBProductA) Show() { fmt.Println(\"FactoryBProductA Show\") } type FactoryBProductB struct {} func (p FactoryBProductB) Show() { fmt.Println(\"FactoryBProductB Show\") } type FactoryA struct {} func (f FactoryA) CreateProductA() AbstractProductA { return \u0026FactoryAProductA{} } func (f FactoryA) CreateProductB() AbstractProductB { return \u0026FactoryAProductB{} } type FactoryB struct {} func (f FactoryB) CreateProductA() AbstractProductA { return \u0026FactoryBProductA{} } func (f FactoryB) CreateProductB() AbstractProductB { return \u0026FactoryBProductB{} } // 业务 /* factoryAProductA := new(FactoryA).CreateProductA() factoryAProductB := new(FactoryA).CreateProductB() factoryBProductA := new(FactoryA).CreateProductA() factoryBProductB := new(FactoryA).CreateProductB() */ ","date":"2022-10-18","objectID":"/3.-abstract-factory/:0:1","tags":null,"title":"抽象工厂模式","uri":"/3.-abstract-factory/"},{"categories":["设计模式"],"content":"TypeScript 的实现 interface ProductA { factory: string usefulFunctionA(): void } interface ProductB { factory: string usefulFunctionB(): void } class ProductA implements ProductA { public factory: string constructor(factory: string){ this.factory = factory } usefulFunctionA() { console.log(`this is ProductA usefulFunctionA, made in ${this.factory}`) } } class ProductB implements ProductB { public factory: string constructor(factory: string){ this.factory = factory } usefulFunctionB() { console.log(`this is ProductB usefulFunctionB, made in ${this.factory}`) } } interface Factory{ factoryName: string createProductA(): ProductA createProductB(): ProductB } class FactoryA implements Factory{ factoryName = 'FactoryA' createProductA() { return new ProductA(this.factoryName) } createProductB() { return new ProductB(this.factoryName) } } class FactoryB implements Factory{ factoryName = 'FactoryB' createProductA() { return new ProductA(this.factoryName) } createProductB() { return new ProductB(this.factoryName) } } const productA: ProductA = new FactoryA().createProductA() productA.usefulFunctionA() const productB: ProductB = new FactoryA().createProductB() productB.usefulFunctionB() const productA1: ProductA = new FactoryB().createProductA() productA1.usefulFunctionA() const productB1: ProductB = new FactoryB().createProductB() productB1.usefulFunctionB() ","date":"2022-10-18","objectID":"/3.-abstract-factory/:0:2","tags":null,"title":"抽象工厂模式","uri":"/3.-abstract-factory/"},{"categories":["设计模式"],"content":" 又叫静态方法模式(因为工厂类定义了一个静态方法) 特点： 工厂类用静态方法实现产品的创建 优点： 将创建实例与使用实例分开，使用者不必关心类对象如何创建，实现了解耦 缺点： 新增产品需要修改工厂类 ","date":"2022-10-18","objectID":"/1.-simple-factory/:0:0","tags":null,"title":"简单工厂模式","uri":"/1.-simple-factory/"},{"categories":["设计模式"],"content":"Golang 实现 package simple_factory import \"fmt\" // 抽象 type AbstractProduct interface { Show() } // 实现 type ProductA struct{} func (p ProductA) Show() { fmt.Println(\"ProductA Show\") } type ProductB struct{} func (p ProductB) Show() { fmt.Println(\"ProductB Show\") } // 逻辑 type Factory struct{} func (f *Factory) CreateProduct(productType string) AbstractProduct { var product AbstractProduct switch productType { case \"ProductA\": product = \u0026ProductA{} case \"ProductB\": product = \u0026ProductB{} } return product } /* * new(Factory).CreateProduct(\"ProductA\") */ ","date":"2022-10-18","objectID":"/1.-simple-factory/:0:1","tags":null,"title":"简单工厂模式","uri":"/1.-simple-factory/"},{"categories":["设计模式"],"content":"TypeScript 实现 abstract class Product { abstract useFunction(): void } class ProductA extends Product { useFunction() { console.log(`ProductA useFunction`) } } class ProductB extends Product { useFunction() { console.log(`ProductB useFunction`) } } class SimpleFactory { public static createProduct(product: string) { switch (product) { case \"A\": return new ProductA(); case \"B\": return new ProductB(); } } } const pro: Product = SimpleFactory.createProduct('A') pro.useFunction() ","date":"2022-10-18","objectID":"/1.-simple-factory/:0:2","tags":null,"title":"简单工厂模式","uri":"/1.-simple-factory/"},{"categories":null,"content":"运行面板 docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name prtainer-test docker.io/portainer/portainer ","date":"2022-10-18","objectID":"/portainer/:0:1","tags":null,"title":"Portainer 的使用","uri":"/portainer/"},{"categories":null,"content":"安装 Agent 在Portainer的架构中，管理节点是Portainer Server，被管理节点通过部署Agent来与Server通信。 按照网络环境的不同，Portainer将Agent分为两种： Portainer Agent 和 Edge Agent。 Portainer Agent：当被管理服务器位于公网时，有公网IP，Server可以主动与其连接。此时，在被管理服务器上部署Portainer Agent来实现与Server之间的通信。 https://docs.portainer.io/v/be-2.12/start/install/agent/docker/linux Edge Agent： 当被管理服务器位于内网时，Server无法主动与其连接。此时，需要在被管理服务器上部署Edge Agent，Edge Agent会周期性的从Server中获取需要执行的任务，从而实现与Server之间的通信。 https://docs.portainer.io/v/be-2.12/start/install/agent/edge 说白了就是一个主动一个被动 Portainer Agent docker run -d -p 9001:9001 --name portainer_agent --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/docker/volumes:/var/lib/docker/volumes portainer/agent:2.12.1 ","date":"2022-10-18","objectID":"/portainer/:0:2","tags":null,"title":"Portainer 的使用","uri":"/portainer/"},{"categories":null,"content":"配置 node 在面板中增加 endpoint 之后就可以使用了 ","date":"2022-10-18","objectID":"/portainer/:0:3","tags":null,"title":"Portainer 的使用","uri":"/portainer/"},{"categories":["golang"],"content":"配置参数可变， 如何设计让未来增加方便， 好维护 package main import ( \"fmt\" \"time\" ) type Conn struct { Host string Port int Timeout time.Duration Retry int } func NewConn( host string, // 必填参数 fs ...func(*Conn), // 可选可变参数 ) *Conn { conn := \u0026Conn{ Host: host, } for _, f := range fs { f(conn) } return conn } func withPort(port int) func(*Conn) { return func(c *Conn) { c.Port = port } } func withTimeout(duration time.Duration) func(*Conn) { return func(c *Conn) { c.Timeout = duration } } func withRetry(retry int) func(*Conn) { return func(c *Conn) { c.Retry = retry } } func main() { con := NewConn( \"localhost\", withRetry(3), withPort(8080), withTimeout(2*time.Second), ) fmt.Printf(\"%#v\", con) } ","date":"2022-10-18","objectID":"/golang/function/:0:0","tags":null,"title":"函数式选项模式","uri":"/golang/function/"},{"categories":["golang","最佳实践"],"content":"经常会用 golang 做一些工具并开源给大家用。如果自己发版，太麻烦。 而且还要交叉编译各个平台。 在网上找到了一个golang的发布工具，只需要在本地输入一行命令就能直接编译好所有的二进制文件。并发布到 github。 goreleaser 官网地址 ","date":"2022-10-18","objectID":"/goreleaser/:0:0","tags":["goreleaser","github"],"title":"利用 goreleaser 发布自己的项目到 github","uri":"/goreleaser/"},{"categories":["golang","最佳实践"],"content":"最后的效果如下： ","date":"2022-10-18","objectID":"/goreleaser/:0:1","tags":["goreleaser","github"],"title":"利用 goreleaser 发布自己的项目到 github","uri":"/goreleaser/"},{"categories":["golang","最佳实践"],"content":"在你的项目下新建 .goreleaser.yaml 文件 # This is an example .goreleaser.yml file with some sensible defaults. # Make sure to check the documentation at https://goreleaser.com before: hooks: # You may remove this if you don't use go modules. - go mod tidy # you may remove this if you don't need go generate - go generate ./... builds: - env: - CGO_ENABLED=0 goos: - linux - windows - darwin goarch: - amd64 - arm64 gobinary: \"garble\" archives: - replacements: linux: Linux windows: Windows amd64: x86_64 darwin: MacOS checksum: name_template: 'checksums.txt' snapshot: name_template: \"{{ incpatch .Version }}-next\" changelog: sort: asc filters: exclude: - '^docs:' - '^test:' # modelines, feel free to remove those if you don't want/use them: # yaml-language-server: $schema=https://goreleaser.com/static/schema.json # vim: set ts=2 sw=2 tw=0 fo=cnqoj ","date":"2022-10-18","objectID":"/goreleaser/:0:2","tags":["goreleaser","github"],"title":"利用 goreleaser 发布自己的项目到 github","uri":"/goreleaser/"},{"categories":["golang","最佳实践"],"content":"在你的项目下新建 .github/workflows/release.yaml 文件 name: goreleaser on: push: # run only against tags tags: - '*' permissions: contents: write # packages: write # issues: write jobs: goreleaser: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: fetch-depth: 0 - run: git fetch --force --tags - uses: actions/setup-go@v3 with: go-version: '\u003e=1.19.2' cache: true # More assembly might be required: Docker logins, GPG, etc. It all depends # on your needs. - run: go install mvdan.cc/garble@latest - uses: goreleaser/goreleaser-action@v2 with: # either 'goreleaser' (default) or 'goreleaser-pro': distribution: goreleaser version: latest args: release --rm-dist env: GITHUB_TOKEN: ${{ secrets.GORELEASER_GITHUB_TOKEN }} # Your GoReleaser Pro key, if you are using the 'goreleaser-pro' # distribution: # GORELEASER_KEY: ${{ secrets.GORELEASER_GITHUB_TOKEN }} ⚠️注意： 这里需要 GITHUB_TOKEN 。需要自己提前配置。 ","date":"2022-10-18","objectID":"/goreleaser/:0:3","tags":["goreleaser","github"],"title":"利用 goreleaser 发布自己的项目到 github","uri":"/goreleaser/"},{"categories":["服务器"],"content":"安装 oh-my-zsh apt install zsh sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" // 如果速度慢可以使用 https://ghproxy.com/ ","date":"2022-10-18","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:1","tags":["docker"],"title":"新装 Ubuntu 服务器","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["服务器"],"content":"安装 tmux sudo apt install tmux ","date":"2022-10-18","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:2","tags":["docker"],"title":"新装 Ubuntu 服务器","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["服务器"],"content":"安装 node.js 1.替换源(16为node版本) curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash - 2. 安装 node sudo apt-get install -y nodejs 3. 安装 yarn curl -sL https://dl.yarnpkg.com/debian/pubkey.gpg | gpg --dearmor | sudo tee /usr/share/keyrings/yarnkey.gpg \u003e/dev/null echo \"deb [signed-by=/usr/share/keyrings/yarnkey.gpg] https://dl.yarnpkg.com/debian stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update \u0026\u0026 sudo apt-get install yarn ","date":"2022-10-18","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:3","tags":["docker"],"title":"新装 Ubuntu 服务器","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["服务器"],"content":"安装 docker 1. docker curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 2. 安装 docker-compose sudo curl -L \"https://ghproxy.com/https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version 怎么解决docker需要sudo才能运行的问题？ Create the docker group if it does not exist $ sudo groupadd docker Add your user to the docker group. $ sudo usermod -aG docker $USER Run the following command or Logout and login again and run (that doesn't work you may need to reboot your machine first) $ newgrp docker Check if docker can be run without root $ docker run hello-world Reboot if still got error $ reboot ","date":"2022-10-18","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:4","tags":["docker"],"title":"新装 Ubuntu 服务器","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]